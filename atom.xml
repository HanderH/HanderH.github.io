<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hsj的博客</title>
  <icon>https://www.gravatar.com/avatar/0b5d6648195c1648e8c43af28a2b4905</icon>
  <subtitle>life and work</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.handerh.top/"/>
  <updated>2019-09-09T11:19:41.674Z</updated>
  <id>http://www.handerh.top/</id>
  
  <author>
    <name>HanderH</name>
    <email>husj0423@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>线程池</title>
    <link href="http://www.handerh.top/2019/09/09/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://www.handerh.top/2019/09/09/线程池/</id>
    <published>2019-09-09T11:04:56.000Z</published>
    <updated>2019-09-09T11:19:41.674Z</updated>
    
    <content type="html"><![CDATA[<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>线程池主要是控制运行线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数超过了最大数量，超出的线程排队等候，等待其它线程执行完毕，再从队列中取出任务来执行。</p><a id="more"></a><p>为什么要用线程池：</p><ul><li>降低资源的消耗，复用已经创建的线程，降低线程的创建和销毁要销毁的资源</li><li>提高响应速度，当任务到达时，任务不需要等到线程创建就立即执行</li><li>提高线程的可管理性，线程是一种稀缺资源，如果无限制的创建，消耗系统资源，利用线程池可以进行统一的分配和调优，监控。</li></ul><p>线程池的种类</p><p>newFixedThreadPool:固定线程数量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">       return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                     0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                     new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>newCachedThreadPool：一池n线程,根据请求的任务创建，如果当前没有线程处理新来的请求任务，则创建新的线程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">       return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                     60L, TimeUnit.SECONDS,</span><br><span class="line">                                     new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>newSingleThreadExecutor：一池单线程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">publicstatic ExecutorService newSingleThreadExecutor() &#123;</span><br><span class="line">        return new FinalizableDelegatedExecutorService</span><br><span class="line">            (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                    0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>newScheduledThreadPool：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public ScheduledThreadPoolExecutor(int corePoolSize) &#123;</span><br><span class="line">        super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,</span><br><span class="line">              new DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程池的7个参数：</p><ul><li>corePoolSize:线程池中的常驻核心线程数</li><li>maximumPoolSize:线程池能够同时容纳执行的最大线程数</li><li>keepAliveTime:多余的空闲线程的存活时间</li><li>unit:keepAliveTime的单位</li><li>workQueue:任务队列，被提交但尚未被执行的任务</li><li>threadFactory:表示生成线程池工作线程的线程工厂，用于创建线程，一般用默认的即可</li><li>handler:拒绝策略，表示当队列满了并且线程大于等于线程池的最大线程数</li></ul><p>线程池的工作机制</p><ol><li>在创建了线程池后，等待提交过来的任务请求</li><li>当调用executor()方法添加一个请求任务时，线程池会做一些判断<ul><li>如果当前运行的线程数量小于corePoolSize,那么马上创建线程运行这个任务</li><li>如果当前运行的线程数量大于corePoolSize,那么当前任务会加入队列</li><li>如果当前队列满了，线程数量小于maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务</li><li>如果当前队列满了线程数量大于maximumPoolSize，那么线程胡启动拒绝策略</li></ul></li><li>当一个线程完成时，会从队列中取下一个任务来执行</li><li>当一个线程空闲，并且超过一定的时间keepAliveTime时，线程池会判断，如果当前的线程数大于corePoolSize,那么这线程就被停掉</li><li>所以线程池的所有任务完成后最终会收缩到corePoolSize的大小</li></ol><p>拒绝策略</p><ul><li>AbortPolicy(默认):直接抛出RejectedExecutionExecution异常阻止系统正常运行</li><li>CallerRunsPolicy:调用者调节机制，不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者</li><li>DiscardOldestPolicy:抛弃任务队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交当前任务</li><li>DiscardPolicy:直接丢弃任务</li></ul><p>自定义线程池</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService es = new ThreadPoolExecutor(2, 5, 2l, TimeUnit.SECONDS,</span><br><span class="line">new LinkedBlockingQueue&lt;Runnable&gt;(3),Executors.defaultThreadFactory(),new ThreadPoolExecutor. AbortPolicy() );</span><br><span class="line">for(int i=0;i&lt;8;i++) &#123;</span><br><span class="line">es.execute(()-&gt;&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName());</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;线程池&quot;&gt;&lt;a href=&quot;#线程池&quot; class=&quot;headerlink&quot; title=&quot;线程池&quot;&gt;&lt;/a&gt;线程池&lt;/h3&gt;&lt;p&gt;线程池主要是控制运行线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数超过了最大数量，超出的线程排队等候，等待其它线程执行完毕，再从队列中取出任务来执行。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://www.handerh.top/categories/java/"/>
    
    
      <category term="java高并发编程" scheme="http://www.handerh.top/tags/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>CountDownLatch CyclicBarrier Semaphore</title>
    <link href="http://www.handerh.top/2019/09/08/CountoDownLatch-CyclicBarrier-Semaphore/"/>
    <id>http://www.handerh.top/2019/09/08/CountoDownLatch-CyclicBarrier-Semaphore/</id>
    <published>2019-09-08T02:05:14.000Z</published>
    <updated>2019-09-08T02:26:56.948Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>让一些线程阻塞直到另一些线程执行完成，有两个方法，一个是countDown()，一个是await(),调用countDown的线程不会被阻塞，调用await的线程才会被阻塞。countDown方法将计数器减一，只有当计数器为0时，调用await的线程才会被执行。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class CountLatchTest &#123;</span><br><span class="line">CountDownLatch count = new CountDownLatch(5);</span><br><span class="line">public void test() &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+&quot;\t 门栓减一&quot;);</span><br><span class="line">count.countDown();</span><br><span class="line">System.out.println(Thread.currentThread().getName()+&quot;\t 还剩&quot;+count.getCount());</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">CountLatchTest ct = new CountLatchTest();</span><br><span class="line">// 线程数量如果小于5，调用await的线程将一直阻塞</span><br><span class="line">for(int i=0;i&lt;5;i++) &#123;</span><br><span class="line">new Thread(()-&gt;&#123;</span><br><span class="line">ct.test();</span><br><span class="line">&#125;).start();</span><br><span class="line">&#125;</span><br><span class="line">Thread.sleep(1000);</span><br><span class="line">ct.count.await();</span><br><span class="line">System.out.println(&quot;main &quot;+&quot;\t 还剩&quot;+ct.count.getCount());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>让一些线程到达一个屏障（同步点）直到所有的线程都到达，屏障才会打开，所有线程才开始执行，调用await方法将线程到达屏障。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class CycliBarrierDemo &#123;</span><br><span class="line"></span><br><span class="line">CyclicBarrier cyclic = new CyclicBarrier(5,()-&gt;&#123;</span><br><span class="line">System.out.println(&quot;所有线程都到了，我可以开始运行了&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">public void test() throws InterruptedException, BrokenBarrierException&#123;</span><br><span class="line">System.out.println(Thread.currentThread()+&quot;运行&quot;);</span><br><span class="line">cyclic.await();</span><br><span class="line">System.out.println(&quot;================&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">CycliBarrierDemo ct = new CycliBarrierDemo();</span><br><span class="line">// 如果运行的线程个数小于5，CyclicBarrier中的线程不会运行</span><br><span class="line">for(int i=0;i&lt;5;i++) &#123;</span><br><span class="line">new Thread(()-&gt;&#123;</span><br><span class="line">try &#123;</span><br><span class="line">Thread.sleep(1000);</span><br><span class="line">ct.test();</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (BrokenBarrierException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###　 Symaphore</p><p>用于多个共享资源的并发使用和并发线程数的控制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class SemaphoreDemo &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">// 用于多个共享资源的并发使用和并发线程数的控制</span><br><span class="line">Semaphore sem = new Semaphore(3);</span><br><span class="line">// 6个线程争抢3个资源</span><br><span class="line">for(int i=0;i&lt;6;i++) &#123;</span><br><span class="line">new Thread(()-&gt;&#123;</span><br><span class="line">try &#123;</span><br><span class="line">sem.acquire();</span><br><span class="line">System.out.println(Thread.currentThread().getName()+&quot;\t获取资源&quot;);</span><br><span class="line">Thread.sleep(3000);</span><br><span class="line">System.out.println(Thread.currentThread().getName()+&quot;\t获取资源三秒后离开&quot;);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;finally &#123;</span><br><span class="line">sem.release();</span><br><span class="line">&#125; </span><br><span class="line">&#125;).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;CountDownLatch&quot;&gt;&lt;a href=&quot;#CountDownLatch&quot; class=&quot;headerlink&quot; title=&quot;CountDownLatch&quot;&gt;&lt;/a&gt;CountDownLatch&lt;/h3&gt;&lt;p&gt;让一些线程阻塞直到另一些线程执行完成，有两个方法，一个是countDown()，一个是await(),调用countDown的线程不会被阻塞，调用await的线程才会被阻塞。countDown方法将计数器减一，只有当计数器为0时，调用await的线程才会被执行。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://www.handerh.top/categories/java/"/>
    
    
      <category term="java高并发编程" scheme="http://www.handerh.top/tags/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>java中的锁</title>
    <link href="http://www.handerh.top/2019/09/04/java%E4%B8%AD%E7%9A%84%E9%94%81/"/>
    <id>http://www.handerh.top/2019/09/04/java中的锁/</id>
    <published>2019-09-04T13:36:56.000Z</published>
    <updated>2019-09-09T11:20:04.442Z</updated>
    
    <content type="html"><![CDATA[<h3 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h3><p>公平锁：每个线程获取锁的机会是公平的，按照申请锁的顺序将线程放进一个FIFO队列中，谁先申请锁谁就先获取锁，每次有线程来抢占锁的时候，都会检查有没有等待队列，如果有，则将该线程加入等待队列</p><p>非公平锁：线程获取锁的机会是不公平的，获取锁的线程会随机抢占</p><p>synchronized实现的锁是一种非公平锁，公平锁可以通过ReentrantLock来实现，同时ReentrantLock也可以实现非公平锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 默认是非公平锁</span><br><span class="line">Lock lock = new ReentrantLock();</span><br><span class="line"> //public ReentrantLock() &#123;</span><br><span class="line"> //     sync = new NonfairSync();</span><br><span class="line"> //&#125;</span><br><span class="line"> </span><br><span class="line"> // 公平锁</span><br><span class="line"> Lock lock = new ReentrantLock(true);</span><br></pre></td></tr></table></figure><h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><p>可重入锁指在同一个线程中外部方法持有的锁可以被内部方法获取</p><p>synchronized和ReentrantLock都是可以实现可重入锁</p><ul><li>synchronized实现的可重入锁</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class TestReEntryLock &#123;</span><br><span class="line">public synchronized void set() &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+&quot;set&quot;);</span><br><span class="line">get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public synchronized void get() &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+&quot;get&quot;);</span><br><span class="line">set();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">TestReEntryLock lock = new TestReEntryLock();</span><br><span class="line">new Thread(()-&gt;&#123;</span><br><span class="line">lock.set();</span><br><span class="line">&#125;,&quot;t1&quot;).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ReentrantLock</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class TestReEntryLock &#123;</span><br><span class="line"></span><br><span class="line">Lock lock = new ReentrantLock();</span><br><span class="line"> public  void set() &#123;</span><br><span class="line"> try &#123;</span><br><span class="line">lock.lock();</span><br><span class="line">System.out.println(Thread.currentThread().getName()+&quot;\t set&quot;);</span><br><span class="line">get();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> public  void get() &#123;</span><br><span class="line"> try &#123;</span><br><span class="line">lock.lock();</span><br><span class="line">System.out.println(Thread.currentThread().getName()+&quot;\t get&quot;);</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">TestReEntryLock lock = new TestReEntryLock();</span><br><span class="line">new Thread(()-&gt;&#123;</span><br><span class="line">lock.set();</span><br><span class="line">&#125;,&quot;t1&quot;).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>支持共享读，不支持共享读写，和写。也就是说支持同时读，但是不支持同时写。这种锁可以提高读的并发性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class WriteAndReadLock &#123;</span><br><span class="line"></span><br><span class="line">ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">// 写操作</span><br><span class="line">public void write() &#123;</span><br><span class="line">rwl.writeLock().lock();</span><br><span class="line">System.out.println(Thread.currentThread().getName()+&quot;正在写&quot;);</span><br><span class="line">try &#123;</span><br><span class="line">TimeUnit.SECONDS.sleep(1);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">rwl.writeLock().unlock();</span><br><span class="line">System.out.println(Thread.currentThread().getName()+&quot;写已经完成&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// 读操作</span><br><span class="line">public void read() &#123;</span><br><span class="line">rwl.readLock().lock();</span><br><span class="line">System.out.println(Thread.currentThread().getName()+&quot;正在读&quot;);</span><br><span class="line">try &#123;</span><br><span class="line">TimeUnit.SECONDS.sleep(1);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+&quot;读已经完成&quot;);</span><br><span class="line">rwl.readLock().unlock();</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">WriteAndReadLock wad = new WriteAndReadLock();</span><br><span class="line">for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">new Thread(()-&gt;&#123;</span><br><span class="line">wad.write();</span><br><span class="line">&#125;).start();</span><br><span class="line">&#125;</span><br><span class="line">for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">new Thread(()-&gt;&#123;</span><br><span class="line">wad.read();</span><br><span class="line">&#125;).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：  每个线程写操作不能被其它操作所打断</p><p>​    Thread-0正在写<br>    Thread-0写已经完成<br>    Thread-1正在写<br>    Thread-1写已经完成<br>    Thread-2正在写<br>    Thread-2写已经完成<br>    Thread-3正在读<br>    Thread-4正在读<br>    Thread-5正在读<br>    Thread-3读已经完成<br>    Thread-4读已经完成<br>    Thread-5读已经完成</p><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>自旋锁在没有获取到锁的情况下不会马上将线程阻塞，而是不断尝试获取锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class RoteBySelf &#123;</span><br><span class="line"></span><br><span class="line">private AtomicReference&lt;Thread&gt; ar = new AtomicReference&lt;Thread&gt;();</span><br><span class="line"></span><br><span class="line">// 手写一个自旋锁</span><br><span class="line">public void lock() &#123;</span><br><span class="line">Thread thread = Thread.currentThread();</span><br><span class="line">System.out.println(thread.getName()+&quot;\t　尝试获取锁&quot;);</span><br><span class="line"></span><br><span class="line">while(!ar.compareAndSet(null,thread)) &#123;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(thread.getName()+&quot;\t　获取锁成功&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void unlock() &#123;</span><br><span class="line">Thread thread = Thread.currentThread();</span><br><span class="line">ar.compareAndSet(thread, null);</span><br><span class="line">System.out.println(thread.getName()+&quot;\t　释放锁成功&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁是多个线程争抢共享资源导致互相等待的一种状态，如果没有外力驱使，那么该状态会一直存在。</p><p>产生死锁的条件：</p><ul><li>互斥：一个资源要么被抢占，要么可用，必须是临界资源</li><li>请求和保持：线程请求到资源后，继续申请资源，并且保持原来所持有的资源</li><li>不可抢占：已经被分配的资源不可被抢占</li><li>环路等待：线程之间互相等待对方释放所持有的资源</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class DeadDemo implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">private Account from;</span><br><span class="line">private Account to;</span><br><span class="line">private int amount;</span><br><span class="line">public DeadDemo(Account from, Account to, int amount) &#123;</span><br><span class="line">this.from = from;</span><br><span class="line">this.to = to;</span><br><span class="line">this.amount = amount;</span><br><span class="line">&#125;</span><br><span class="line">public void run() &#123;</span><br><span class="line">synchronized(from) &#123;</span><br><span class="line">synchronized (to) &#123;</span><br><span class="line">from.amount = from.amount-amount;</span><br><span class="line">to.amount = to.amount+10;</span><br><span class="line">System.out.println(&quot;success&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Account a1 = new Account();</span><br><span class="line">Account a2 = new Account();</span><br><span class="line">new Thread(new DeadDemo(a1,a2,10)).start();</span><br><span class="line">new Thread(new DeadDemo(a2,a1,10)).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Account&#123;</span><br><span class="line"> int amount;</span><br><span class="line">&#125;</span><br><span class="line">//死锁排查</span><br><span class="line">jps -l</span><br><span class="line">jstack 进程号</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;公平锁与非公平锁&quot;&gt;&lt;a href=&quot;#公平锁与非公平锁&quot; class=&quot;headerlink&quot; title=&quot;公平锁与非公平锁&quot;&gt;&lt;/a&gt;公平锁与非公平锁&lt;/h3&gt;&lt;p&gt;公平锁：每个线程获取锁的机会是公平的，按照申请锁的顺序将线程放进一个FIFO队列中，谁先申请
      
    
    </summary>
    
      <category term="java" scheme="http://www.handerh.top/categories/java/"/>
    
    
      <category term="java高并发编程" scheme="http://www.handerh.top/tags/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>集合多线程下的安全性</title>
    <link href="http://www.handerh.top/2019/09/03/%E9%9B%86%E5%90%88%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7/"/>
    <id>http://www.handerh.top/2019/09/03/集合多线程下的安全性/</id>
    <published>2019-09-03T03:45:52.000Z</published>
    <updated>2019-09-07T01:57:56.848Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ArrayList多线程下的安全性"><a href="#ArrayList多线程下的安全性" class="headerlink" title="ArrayList多线程下的安全性"></a>ArrayList多线程下的安全性</h3><h3 id="多线程下运行问题"><a href="#多线程下运行问题" class="headerlink" title="多线程下运行问题"></a>多线程下运行问题</h3><p>ArrayList之前也用过很多次，但是都是在单线程下使用的，今天测试了一些ArrayList在多少次情况下运行的状况</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">// 启动100个检查网list中添加数据</span><br><span class="line">for(int i=0;i&lt;100;i++) &#123;</span><br><span class="line">new Thread(()-&gt;&#123;</span><br><span class="line">list.add(UUID.randomUUID().toString().substring(0,8));</span><br><span class="line">System.out.println(list);</span><br><span class="line">&#125;).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p>​    抛出：java.util.ConcurrentModificationException</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><ul><li>使用Vector,Vector是一个线程安全类，它在每个方法上都加了Synchronized同步锁</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new Vector&lt;String&gt;();</span><br></pre></td></tr></table></figure><ul><li>使用Collections.synchronizedList(new ArrayList<string>());将list转化成一个线程安全的集合</string></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;String&gt;());</span><br></pre></td></tr></table></figure><ul><li>使用CopyOnWriteArrayList</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list =new CopyOnWriteArrayList&lt;String&gt;();</span><br></pre></td></tr></table></figure><p>CopyOnWriteArrayList是一种写时复制的容器，利用了ReentrantLock实现。它在添加元素的时候不会直接往Object数组中添加，它首先会拷贝一个数组 Object[] newElements，然后往这个新的数组中添加元素，最后再将原数组的引用指向新数组。CopyOnWriteArrayList利用了读写分离的思想，查询元素的时候不添加锁，增加元素的时候加锁.这样做的好处是可以对容器并发的读而不需要加锁。</p><h3 id="HashSet-HashMap"><a href="#HashSet-HashMap" class="headerlink" title="HashSet,HashMap"></a>HashSet,HashMap</h3><p>HashSet与HashMap在并发情况下同样会产生java.util.ConcurrentModificationException</p><p>HashSet和Arraylist同样可以使用Collections.synchronizedSet()和CopyOnWriteArraySet()解决</p><p>对于HashMap使用ConcurrentHashMap，在这里先解释一下HashMap的源码</p><p>1.8HashMap底层源码的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                   boolean evict) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">        // 判断当前数组是否为空</span><br><span class="line">        if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">        // 初始化</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">            //根据数组长度和hash值获取到下标对应的节点，并判断是否为空</span><br><span class="line">        if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">        //为空，创建新的Node</span><br><span class="line">            tab[i] = newNode(hash, key, value, null);</span><br><span class="line">        else &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            // 不为空，判断当前的的节点的hash值与新插入的hash值，以及key是否相等</span><br><span class="line">            if (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                // 相等将当前的节点复制给e</span><br><span class="line">                e = p;</span><br><span class="line">                // 遍历红黑数</span><br><span class="line">            else if (p instanceof TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">            else &#123;</span><br><span class="line">            // 变量链表</span><br><span class="line">                for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">                // 如果到了链表的最后一个节点，将新的节点插入到链表尾部</span><br><span class="line">                    if ((e = p.next) == null) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, null);</span><br><span class="line">                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 链表中存在与新节点相等的节点，跳出循环</span><br><span class="line">                    if (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                        break;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果e不为空 替换旧值，并将旧值返回</span><br><span class="line">            if (e != null) &#123; // existing mapping for key</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                return oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 快速失败机制</span><br><span class="line">        ++modCount;</span><br><span class="line">        // 如果数组中所有的值的大小，大于阈值进行扩容</span><br><span class="line">        if (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>1.7的HashMap源码实现逻辑与1.8差不多,大概为下面的几步</p><pre><code>1.判断数组是否为空，为空进行初始化inflateTable(threshold),初始化时数组容量为2的次方</code></pre><p>​        2.判断Key是否为空，如果key为空将key为空的值添加</p><p>​        3.如果key不为空，获取key的hash值，根据key的hash值和数组长度获取数组对应的下标</p><p>​        4.找到对应下标后，判断这个桶中的hash以及key是否相等，相等覆盖j旧值</p><p>​        5.如果没有，将该节点加入到链表头部</p><p>​        在第5步前面，也就是在插入之前其实是需要扩容的（resize）</p><p>​        当size&gt;=threshold===&gt;resize====&gt;transfer</p><p>了解了HashMap底层实现之后，对于ConcurrentHashMap就可以更好的了解了    </p><p>对于1.8的ConcurrentHashMap，采用的 synchronized+CAS+红黑树,synchronized每次锁住的都是链表的头节点，在每次向map添加元素的时候，需要先获得头节点的对象锁。</p><p>对于1.7的ConcurrentHashMap，采用的Segment+Lock,初始化时将每个segment的大小设置为2的次方数，先构造第一个segment的大小，其它segment的大小都是根据第一个segment大小进行构建,在调用put方法的使用，调用的是segment中的put方法，而segment继承了ReentrantLock类，从而达实现线程安全的目的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;ArrayList多线程下的安全性&quot;&gt;&lt;a href=&quot;#ArrayList多线程下的安全性&quot; class=&quot;headerlink&quot; title=&quot;ArrayList多线程下的安全性&quot;&gt;&lt;/a&gt;ArrayList多线程下的安全性&lt;/h3&gt;&lt;h3 id=&quot;多线程下运行问题&quot;&gt;&lt;a href=&quot;#多线程下运行问题&quot; class=&quot;headerlink&quot; title=&quot;多线程下运行问题&quot;&gt;&lt;/a&gt;多线程下运行问题&lt;/h3&gt;&lt;p&gt;ArrayList之前也用过很多次，但是都是在单线程下使用的，今天测试了一些ArrayList在多少次情况下运行的状况&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://www.handerh.top/categories/java/"/>
    
    
      <category term="java并发编程" scheme="http://www.handerh.top/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>CAS</title>
    <link href="http://www.handerh.top/2019/09/02/CAS/"/>
    <id>http://www.handerh.top/2019/09/02/CAS/</id>
    <published>2019-09-02T08:38:07.000Z</published>
    <updated>2019-09-03T08:05:17.818Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CAS原理"><a href="#CAS原理" class="headerlink" title="CAS原理"></a>CAS原理</h3><p>CAS(Compare And Swap)是用于多线程同步的原子性指令，CAS主要通过三个值来实现，原始内存的值，给定的预期值，给定更新值，只有当原始内存的值与给定的预期值相等的情况下，才将更新值返回。</p><p>假设有两个线程A,B同时执行a=a+1</p><a id="more"></a><p>根据JMM内存模型，A,B线程分别拷贝一份副本到自己的内存中，假设此时A线程挂起，线程B对a的值进行修改，线程B首先会判断拷贝的副本值是否与共享内存的值相等，如果相等，对a进行更新，并写回主内存，此时线程A要修改a了，但是线程A发现拷贝的副本值与共享内存中的值不同，线程A会重新从共享内存中拷贝副本进行修改。</p><h3 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h3><ul><li>基本类型：AtomicInteger AtomicLong  AtomicBoolean</li><li>数组类型：AtomicIntegerArray AtomicLongArray  AtomicReferenceArray</li><li>引用类型：AtomicReference</li></ul><p>底层是通过sun.misc.Unsafe+CAS思想来实现的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final int getAndIncrement() &#123;</span><br><span class="line">      return unsafe.getAndAddInt(this, valueOffset, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Unsafe中的类都是native方法，它可以通过valueOffset拿到在内存中的值，然后利用一个do…while循环，判断内存中的值是否与当前的相等，如果相等则对值进行更新，并将更新后的值返回，否则，进入循环中，重新获取内存值的最新值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public final int getAndAddInt（object o,long offset,int delta)&#123;</span><br><span class="line">    int v;</span><br><span class="line">    do&#123;</span><br><span class="line">        v = getIntVolatile(o,offset);//拿到内存位置的最新值</span><br><span class="line">    &#125;while(!compareAndSwapInt(o.offset,v,v+delta))//o.offset的值 == v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CAS缺点"><a href="#CAS缺点" class="headerlink" title="CAS缺点"></a>CAS缺点</h3><ul><li>如果CAS失败，会一直进行尝试，如果CAS长时间一直不成功。可能会给CPU带来负担</li><li>只能保证一个共享变量的原子操作</li><li>ABA问题</li></ul><h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h3><p>假设有两个线程t1,t2一个共享变量A,线程t1,t2分别将A拷贝一份到自己的内存，这时t1先将A的值改为B</p><p>，再将B的值改为A，这时线程T2要修改值，发现符合CAS，对A的值进行更新。这就是ABA问题,线程t1对A的值进行过修改，线程t2完全忽略了这个过程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">AtomicReference&lt;Integer&gt; ar = new AtomicReference&lt;Integer&gt;(100);</span><br><span class="line">// 线程t1</span><br><span class="line">new Thread(()-&gt;&#123;</span><br><span class="line">ar.compareAndSet(100, 101);</span><br><span class="line">ar.compareAndSet(101,100);</span><br><span class="line">&#125;,&quot;t1&quot;).start();</span><br><span class="line">// 线程t2</span><br><span class="line">new Thread(()-&gt;&#123;</span><br><span class="line">try &#123;</span><br><span class="line">Thread.sleep(1000);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;是否修改成功：&quot;+ar.compareAndSet(100, 101)+&quot;\t当前最新值为&quot;+ar.get());</span><br><span class="line">&#125;,&quot;t2&quot;).start();</span><br></pre></td></tr></table></figure><p><strong>打印结果</strong>    ：<br><strong>是否修改成功：true    当前最新值为101</strong></p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>使用原子引用+版本号控制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 初始值为 100，stamp为 1</span><br><span class="line">AtomicStampedReference&lt;Integer&gt; asr = new AtomicStampedReference&lt;Integer&gt;(100, 1);</span><br><span class="line">// 线程t1执行ABA操作，版本更新</span><br><span class="line">new Thread(()-&gt;&#123;</span><br><span class="line">int stamp = asr.getStamp();</span><br><span class="line">System.out.println(&quot;当前线程&quot;+Thread.currentThread().getName()+&quot;的版本号&quot;+stamp);</span><br><span class="line">try &#123;</span><br><span class="line">//等待线程t2拿到版本号</span><br><span class="line">Thread.sleep(1000);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">asr.compareAndSet(100, 101, asr.getStamp(), asr.getStamp()+1);</span><br><span class="line">System.out.println(Thread.currentThread().getName()+&quot;\t&quot;+&quot;当前版本号&quot;+asr.getStamp());</span><br><span class="line">asr.compareAndSet(101, 100, asr.getStamp(), asr.getStamp()+1);</span><br><span class="line">System.out.println(Thread.currentThread().getName()+&quot;\t&quot;+&quot;当前版本号&quot;+asr.getStamp());</span><br><span class="line">&#125;,&quot;t1&quot;).start();</span><br><span class="line">// 线程t2修改值</span><br><span class="line">new Thread(()-&gt;&#123;</span><br><span class="line">int stamp = asr.getStamp();</span><br><span class="line">System.out.println(&quot;当前线程&quot;+Thread.currentThread().getName()+&quot;的版本号&quot;+stamp);</span><br><span class="line">try &#123;</span><br><span class="line">// 线程t2拿到版本号后，交给线程t1执行ABA操作</span><br><span class="line">Thread.sleep(3000);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">boolean  res = asr.compareAndSet(100, 2019, stamp, stamp+1);</span><br><span class="line">System.out.print(Thread.currentThread().getName()+&quot;\t&quot;);</span><br><span class="line">System.out.println(&quot;是否修改成功:&quot;+res+&quot;当前最新版本号:&quot;+asr.getStamp()+&quot;当前最新值:&quot;+asr.getReference());</span><br><span class="line">&#125;,&quot;t2&quot;).start();</span><br></pre></td></tr></table></figure><p><strong>打印结果：</strong></p><p><strong>当前线程t1的版本号1</strong><br><strong>当前线程t2的版本号1</strong><br><strong>t1    当前版本号2</strong><br><strong>t1    当前版本号3</strong><br><strong>t2    是否修改成功:false当前最新版本号:3当前最新值</strong></p><p>结论：使用使用原子引用+版本号控制可以解决ABA问题，线程t1修改两次后，版本号变化，线程t2在对值修改的时候发现版本号不对，就不会对值进行修改</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;CAS原理&quot;&gt;&lt;a href=&quot;#CAS原理&quot; class=&quot;headerlink&quot; title=&quot;CAS原理&quot;&gt;&lt;/a&gt;CAS原理&lt;/h3&gt;&lt;p&gt;CAS(Compare And Swap)是用于多线程同步的原子性指令，CAS主要通过三个值来实现，原始内存的值，给定的预期值，给定更新值，只有当原始内存的值与给定的预期值相等的情况下，才将更新值返回。&lt;/p&gt;
&lt;p&gt;假设有两个线程A,B同时执行a=a+1&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://www.handerh.top/categories/java/"/>
    
    
      <category term="java并发编程" scheme="http://www.handerh.top/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>kafka学习笔记</title>
    <link href="http://www.handerh.top/2019/08/13/kafka%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.handerh.top/2019/08/13/kafka学习笔记/</id>
    <published>2019-08-13T06:35:24.000Z</published>
    <updated>2019-08-20T05:22:06.101Z</updated>
    
    <content type="html"><![CDATA[<h3 id="kafka的安装"><a href="#kafka的安装" class="headerlink" title="kafka的安装"></a>kafka的安装</h3><a id="more"></a><ol><li>解压</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf kafka_2.11-0.11.0.0.tgz -C /opt/module/</span><br></pre></td></tr></table></figure><ol start="2"><li>修改解压后的文件名，方便配置</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv kafka_2.11-0.11.0.0/ kafka</span><br></pre></td></tr></table></figure><ol start="3"><li>在/opt/module/kafka目录下创建logs文件夹、</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir logs</span><br></pre></td></tr></table></figure><ol start="4"><li>修改配置文件</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> vi server.properties</span><br><span class="line"> </span><br><span class="line">#broker的全局唯一编号，不能重复</span><br><span class="line">broker.id=0</span><br><span class="line">#删除topic功能使能</span><br><span class="line">delete.topic.enable=true</span><br><span class="line">#处理网络请求的线程数量</span><br><span class="line">num.network.threads=3</span><br><span class="line">#用来处理磁盘IO的现成数量</span><br><span class="line">num.io.threads=8</span><br><span class="line">#发送套接字的缓冲区大小</span><br><span class="line">socket.send.buffer.bytes=102400</span><br><span class="line">#接收套接字的缓冲区大小</span><br><span class="line">socket.receive.buffer.bytes=102400</span><br><span class="line">#请求套接字的缓冲区大小</span><br><span class="line">socket.request.max.bytes=104857600</span><br><span class="line">#kafka运行日志存放的路径</span><br><span class="line">log.dirs=/opt/module/kafka/logs</span><br><span class="line">#topic在当前broker上的分区个数</span><br><span class="line">num.partitions=1</span><br><span class="line">#用来恢复和清理data下数据的线程数量</span><br><span class="line">num.recovery.threads.per.data.dir=1</span><br><span class="line">#segment文件保留的最长时间，超时将被删除</span><br><span class="line">log.retention.hours=168</span><br><span class="line">#配置连接Zookeeper集群地址</span><br><span class="line">zookeeper.connect=hadoop01:2181,hadoop02:2181,hadoop03:2181</span><br></pre></td></tr></table></figure><ol start="5"><li>hadoop02,hadoop03进行如上配置，并且修改broker.id=1,broker.id=2</li><li>启动集群</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 三台机器都需要启动</span><br><span class="line">bin/kafka-server-start.sh config/server.properties &amp;</span><br></pre></td></tr></table></figure><h3 id="kafka架构"><a href="#kafka架构" class="headerlink" title="kafka架构"></a>kafka架构</h3><p>Kafka是一个分布式消息队列，Kafka对消息的保存是基于Topic进行归类的，发送消息的称为Producer,接受消息的称为Consumer。Kafka的每个实例被称为broker。kafka集群依赖zookeeper集群来保存一些元数据.</p><p><img src="https://handerh-1259550163.cos.ap-shanghai.myqcloud.com/java/kafka/kafka1.png" alt></p><p><img src="https://handerh-1259550163.cos.ap-shanghai.myqcloud.com/java/kafka/kafka2.png" alt></p><ul><li>Producer:消息生产者，就是向kafka broker发消息的客户端</li><li>Consumer：消息消费者，向kafka broker取消息的客户端</li><li>Topic：存储消息的队列</li><li>Consumer Group:一个消费者组，一个topic可以被多个消费者组中的消费者消费，topic中的每个分区只能被同一个消费者组中的一个消费者消费，但是可以被不同组的消费者消费</li><li>Broker：每一台kafka机器就是一个Broker</li><li>Partition:一个topic可以分为多个partition,每个partition拥有一部分的数据</li><li>Offset：数据的偏移量</li></ul><h3 id="命令操作"><a href="#命令操作" class="headerlink" title="命令操作"></a>命令操作</h3><ul><li>查看当前服务器中的所有topic</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-topics.sh --zookeeper localhost:2181 --list</span><br></pre></td></tr></table></figure><ul><li>创建topic</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-topics.sh --zookeeper localhost:2181 --create --replication-factor 1 --partitions 1 --topic first</span><br></pre></td></tr></table></figure><ul><li>删除topic</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-topics.sh --zookeeper localhost:2181 --delete --topic first</span><br></pre></td></tr></table></figure><ul><li>发送消息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-console-producer.sh --broker-list localhost:9092 --topic first</span><br></pre></td></tr></table></figure><ul><li>消费消息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-console-consumer.sh --zookeeper localhost:2181 --topic first</span><br></pre></td></tr></table></figure><ul><li>查看topic状态</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-topics.sh --zookeeper localhost:2181 --describe --topic first</span><br></pre></td></tr></table></figure><h3 id="Producer写入流程"><a href="#Producer写入流程" class="headerlink" title="Producer写入流程"></a>Producer写入流程</h3><p>producer的写入流程需要根据设置的ack机制来进行数据的写入</p><p>ack=0,producer将消息发送到出去，不管发送的数据有没有成功写入到partition leader所在的磁盘，producer都不再关心这条数据。</p><p>ack=1，producer将消息发送出去，只要partition leader接受到消息并且写入到磁盘，就认为成功，不管其它follower有没有同步这条消息</p><p>ack=all,producer将消息发送出去,partition leader成功写入消息后要求ISR列表中的follower也将数据成功同步到自己的磁盘。</p><p>ISR列表(跟leader始终保持同步的列表)</p><h4 id="存储策略"><a href="#存储策略" class="headerlink" title="存储策略"></a>存储策略</h4><p>无论是否消费，kafka都会保留所有消息，有两种策略可以删除旧数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1）基于时间：log.retention.hours=168</span><br><span class="line">2）基于大小：log.retention.bytes=1073741824</span><br></pre></td></tr></table></figure><h3 id="javaapi"><a href="#javaapi" class="headerlink" title="javaapi"></a>javaapi</h3><h4 id="consumer"><a href="#consumer" class="headerlink" title="consumer"></a>consumer</h4><p>不需要自行管理offset，分区，副本,系统通过zookeeper自行管理，消费者会根据上一次记录在zookeeper中的offset区接着获取数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class MyConsumer &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">    </span><br><span class="line">        Properties props = new Properties();</span><br><span class="line">        // 定义 kakfa 服务的地址，不需要将所有 broker 指定上</span><br><span class="line">        props.put(&quot;bootstrap.servers&quot;, &quot;hadoop03:9092&quot;);</span><br><span class="line">        // 制定 consumer group</span><br><span class="line">        props.put(&quot;group.id&quot;, &quot;test&quot;);</span><br><span class="line">        // 是否自动确认 offset</span><br><span class="line">        props.put(&quot;enable.auto.commit&quot;, &quot;true&quot;);</span><br><span class="line">        // 自动确认 offset 的时间间隔</span><br><span class="line">        props.put(&quot;auto.commit.interval.ms&quot;, &quot;1000&quot;);</span><br><span class="line">        // key 的序列化类</span><br><span class="line">        props.put(&quot;key.deserializer&quot;,</span><br><span class="line">                &quot;org.apache.kafka.common.serialization.StringDeserializer&quot;);</span><br><span class="line">        // value 的序列化类</span><br><span class="line">        props.put(&quot;value.deserializer&quot;,</span><br><span class="line">                &quot;org.apache.kafka.common.serialization.StringDeserializer&quot;);</span><br><span class="line"></span><br><span class="line">        Consumer&lt;String,String&gt; consumer = new KafkaConsumer&lt;String, String&gt;(props);s</span><br><span class="line">        consumer.subscribe(Arrays.asList(&quot;first&quot;));</span><br><span class="line">        while (true)&#123;</span><br><span class="line">            ConsumerRecords&lt;String, String&gt; poll = consumer.poll(Duration.ofMillis(100).getSeconds());</span><br><span class="line"></span><br><span class="line">            for (ConsumerRecord&lt;String, String&gt; record : poll) &#123;</span><br><span class="line">                System.out.println(record.topic()+&quot;--&quot;+record.partition()+&quot;--&quot;+record.offset()+&quot;--&quot;+record.value());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="producer"><a href="#producer" class="headerlink" title="producer"></a>producer</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class MyProducer &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Properties props = new Properties();</span><br><span class="line">        // Kafka 服务端的主机名和端口号</span><br><span class="line">        props.put(&quot;bootstrap.servers&quot;, &quot;hadoop03:9092&quot;);</span><br><span class="line">        // 等待所有副本节点的应答</span><br><span class="line">        props.put(&quot;acks&quot;, &quot;all&quot;);</span><br><span class="line">        // 消息发送最大尝试次数</span><br><span class="line">        props.put(&quot;retries&quot;, 0);</span><br><span class="line">        // 一批消息处理大小</span><br><span class="line">        props.put(&quot;batch.size&quot;, 16384);</span><br><span class="line">        // 请求延时</span><br><span class="line">        props.put(&quot;linger.ms&quot;, 1);</span><br><span class="line">        props.put(&quot;buffer.memory&quot;, 33554432);</span><br><span class="line">        // key 序列化</span><br><span class="line">        props.put(&quot;key.serializer&quot;,</span><br><span class="line">                &quot;org.apache.kafka.common.serialization.StringSerializer&quot;);</span><br><span class="line">        // value 序列化</span><br><span class="line">        props.put(&quot;value.serializer&quot;,</span><br><span class="line">                &quot;org.apache.kafka.common.serialization.StringSerializer&quot;);</span><br><span class="line">        props.put(&quot;partitioner.class&quot;,MyPartitioner.class);</span><br><span class="line">        Producer&lt;String,String&gt; producer = new KafkaProducer&lt;String, String&gt;(props);</span><br><span class="line"></span><br><span class="line">//        for (int i=0;i&lt;10;i++)&#123;</span><br><span class="line">//            producer.send(new ProducerRecord&lt;String, String&gt;(&quot;second&quot;,String.valueOf(i)));</span><br><span class="line">//        &#125;</span><br><span class="line">        for (int i=0;i&lt;10;i++)&#123;</span><br><span class="line"></span><br><span class="line">            producer.send(new ProducerRecord&lt;String, String&gt;(&quot;first&quot;, String.valueOf(i)), new Callback() &#123;</span><br><span class="line">                public void onCompletion(RecordMetadata recordMetadata, Exception e) &#123;</span><br><span class="line"></span><br><span class="line">                    if(e==null)&#123;</span><br><span class="line">                        System.out.println(recordMetadata.topic()+&quot;==&quot;+recordMetadata.partition()+&quot;==&quot;+recordMetadata.offset());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        producer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p>实现在每条记录前加上时间戳并且统计成功与失败的次数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">// 时间戳</span><br><span class="line">public class TimeIntercepter implements ProducerInterceptor&lt;String,String&gt;&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">public ProducerRecord&lt;String, String&gt; onSend(ProducerRecord&lt;String, String&gt; producerRecord) &#123;</span><br><span class="line">        return new ProducerRecord(producerRecord.topic(),producerRecord.key(),System.currentTimeMillis()+&quot; &quot;+producerRecord.value());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void onAcknowledgement(RecordMetadata recordMetadata, Exception e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void close() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void configure(Map&lt;String, ?&gt; map) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 计算成功与失败的次数</span><br><span class="line">public class CountInterceptor implements ProducerInterceptor &#123;</span><br><span class="line">    private int successCount = 0;</span><br><span class="line">    private int failCount = 0;</span><br><span class="line">    @Override</span><br><span class="line">    public ProducerRecord onSend(ProducerRecord producerRecord) &#123;</span><br><span class="line">        return new ProducerRecord(producerRecord.topic(),producerRecord.key(),System.currentTimeMillis()+&quot; &quot;+producerRecord.value());</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void onAcknowledgement(RecordMetadata recordMetadata, Exception e) &#123;</span><br><span class="line">        if (e == null)&#123;</span><br><span class="line">            successCount++;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            failCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void close() &#123;</span><br><span class="line">        System.out.println(&quot;成功次数: &quot;+successCount+&quot; 失败次数:&quot;+failCount);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void configure(Map&lt;String, ?&gt; map) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 在producer端进行配置</span><br><span class="line"> ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line"> list.add(&quot;interceptor.TimeIntercepter&quot;);</span><br><span class="line"> list.add(&quot;interceptor.CountInterceptor&quot;);</span><br><span class="line"> props.put(ProducerConfig.INTERCEPTOR_CLASSES_CONFIG,list);</span><br></pre></td></tr></table></figure><h3 id="Kafka与Flume的比较"><a href="#Kafka与Flume的比较" class="headerlink" title="Kafka与Flume的比较"></a>Kafka与Flume的比较</h3><ol><li><p>kafka和flume都是日志系统。kafka是一种消息队列，自带存储，提供push和pull存取数据功能。flume以管道流的方式实现数据的采集，分为agent（数据采集器）[source channel sink]。</p></li><li><p>flume的数据采集部分做的很好，可以定制很多数据源，而Kafka更方便用于下游消费者众多的情况。</p><p>flume与kafka的集成</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># define</span><br><span class="line">a1.sources = r1</span><br><span class="line">a1.sinks = k1</span><br><span class="line">a1.channels = c1</span><br><span class="line"></span><br><span class="line"># source</span><br><span class="line">a1.sources.r1.type = exec</span><br><span class="line">a1.sources.r1.command = tail -F -c +0 /opt/module/datas/flume.log</span><br><span class="line">a1.sources.r1.shell = /bin/bash -c</span><br><span class="line"></span><br><span class="line"># sink</span><br><span class="line">a1.sinks.k1.type = org.apache.flume.sink.kafka.KafkaSink</span><br><span class="line">a1.sinks.k1.kafka.bootstrap.servers =hadoop1:9092,hadoop2:9092,hadoo3:9092</span><br><span class="line">a1.sinks.k1.kafka.topic = first </span><br><span class="line">a1.sinks.k1.kafka.flumeBatchSize = 20</span><br><span class="line">a1.sinks.k1.kafka.producer.acks = 1</span><br><span class="line">a1.sinks.k1.kafka.producer.linger.ms = 1</span><br><span class="line"></span><br><span class="line"># channel</span><br><span class="line">a1.channels.c1.type = memory</span><br><span class="line">a1.channels.c1.capacity = 1000</span><br><span class="line">a1.channels.c1.transactionCapacity = 100</span><br><span class="line"></span><br><span class="line"># bind</span><br><span class="line">a1.sources.r1.channels = c1</span><br><span class="line">a1.sinks.k1.channel = c1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;kafka的安装&quot;&gt;&lt;a href=&quot;#kafka的安装&quot; class=&quot;headerlink&quot; title=&quot;kafka的安装&quot;&gt;&lt;/a&gt;kafka的安装&lt;/h3&gt;
    
    </summary>
    
      <category term="kafka" scheme="http://www.handerh.top/categories/kafka/"/>
    
    
      <category term="kafka" scheme="http://www.handerh.top/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>spark sql</title>
    <link href="http://www.handerh.top/2019/08/09/spark-sql/"/>
    <id>http://www.handerh.top/2019/08/09/spark-sql/</id>
    <published>2019-08-09T12:49:49.000Z</published>
    <updated>2019-09-04T01:26:58.796Z</updated>
    
    <content type="html"><![CDATA[<h3 id="spark-sql的概念"><a href="#spark-sql的概念" class="headerlink" title="spark sql的概念"></a>spark sql的概念</h3><p>spark sql是 是spark用来处理结构化数据的一个模块，提供了DataFrame和DataSet两个新的抽象概念。与RDD类似，DataSet和DataFrame都是分布式数据容器，DataFrame更像穿透数据库二维表格，除了记录数据之外，还记录数据的结构信息。DataFrame是Row对象的集合，而DataSet是DataFrame的一个扩展，DataSet每一个record存储的是一个强类型值而不是一个Row。RDD，DataSet和DataFram的共同点：三者都是分布式的弹性数据集，三者都有惰性机制，都有partition机制，有许多共同函数。三者可以相互转化</p><a id="more"></a><h3 id="DataFrame的创建"><a href="#DataFrame的创建" class="headerlink" title="DataFrame的创建"></a>DataFrame的创建</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">val spark = SparkSession.builder().appName(&quot;test1&quot;).master(&quot;local[*]&quot;).getOrCreate()</span><br><span class="line">//1. 从文件中读取</span><br><span class="line">val df = spark.read.json(&quot;people.json&quot;)</span><br><span class="line"></span><br><span class="line">//2. createDataFrame[A &lt;: Product : TypeTag](data: Seq[A])</span><br><span class="line">import  spark.implicits</span><br><span class="line">// A &lt;: Product  :case class 或者 元组</span><br><span class="line">val df = spark.createDataFrame[Persion](Seq(Persion(&quot;zs&quot;,18),Persion(&quot;lisi&quot;,20)))</span><br><span class="line">// 需要一个样例类</span><br><span class="line">case class Persion(name:String,age:Int)</span><br><span class="line"></span><br><span class="line">//3.createDataFrame(rowRDD: RDD[Row], schema: StructType)</span><br><span class="line">val rdd: RDD[Row] =  sc.parallelize(Seq(Row(&quot;zs&quot;,19),Row(&quot;lisi&quot;,14)))</span><br><span class="line">val schemal = StructType(Seq(StructField(&quot;name&quot;,StringType),StructField(&quot;age&quot;,IntegerType)))</span><br><span class="line">val df = spark.createDataFrame(rdd,schemal)</span><br></pre></td></tr></table></figure><h3 id="RDD，DataSet和DatDaFram互相转换"><a href="#RDD，DataSet和DatDaFram互相转换" class="headerlink" title="RDD，DataSet和DatDaFram互相转换"></a>RDD，DataSet和DatDaFram互相转换</h3><ul><li>RDD =》DataFrame</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">case class People(var name:String,var age:Int)</span><br><span class="line"></span><br><span class="line">val rdd = spark.sparkContext.textFile(&quot;people.txt&quot;)</span><br><span class="line">val rdd2: RDD[People] = rdd.map(line =&gt; (People(line.split(&quot;,&quot;)(0),line.split(&quot;,&quot;)(1).trim.toInt)))</span><br><span class="line">val rdd3:RDD[(String,Int)] = rdd.map(line =&gt; ((line.split(&quot;,&quot;)(0),line.split(&quot;,&quot;)(1).trim.toInt)))</span><br><span class="line">// rdd2 =&gt; df 样例类</span><br><span class="line">val dataf: DataFrame = rdd2.toDF()</span><br><span class="line">dataf.foreach(row =&gt; println(row.getString(0)+&quot; &quot;+row.getInt(1)))</span><br><span class="line">// rdd3 =&gt; df 元组</span><br><span class="line">val dataf: DataFrame = rdd3.toDF()</span><br><span class="line">dataf.foreach(row =&gt; println(row.getString(0)+&quot; &quot;+row.getInt(1)))</span><br></pre></td></tr></table></figure><ul><li>RDD =》DataSet</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 样例类 可以看出DataSet是一种强类型</span><br><span class="line">val dataS: Dataset[People] = rdd2.toDS()</span><br><span class="line">dataS.foreach(peo =&gt; println(peo.name +&quot; &quot;+peo.age))</span><br><span class="line">// 元组</span><br><span class="line">val dataS: Dataset[(String, Int)] = rdd3.toDS()</span><br><span class="line">dataS.foreach(line=&gt;(println(line._1+&quot; &quot;+line._2)))</span><br></pre></td></tr></table></figure><ul><li>DataFrame =》 RDD</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val dfRdd: RDD[Row] =  .rdd</span><br><span class="line">dfRdd.foreach(row =&gt; println(row.getString(0)+&quot;: &quot;+row.getInt(1)))</span><br></pre></td></tr></table></figure><ul><li>DataFrame =》 DataSet</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 注意：DF转DS的时候，转换到DF的类型需要与DS的类型一致，如果这里的DF是由RDD[People]转来的</span><br><span class="line">// 所以Dataset只能为Dataset[People]</span><br><span class="line">val dfDs: Dataset[People] = dataf.as[People]</span><br><span class="line">dfDs.foreach(peo =&gt; println(peo.name+&quot;: &quot;+peo.age))</span><br></pre></td></tr></table></figure><ul><li>DataSet =》 RDD</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val dsRdd: RDD[People] = dataS.rdd</span><br><span class="line">dsRdd.foreach(peo =&gt; println(peo.name+&quot;: &quot;+peo.age))</span><br></pre></td></tr></table></figure><ul><li>DataSet =》 DataFrame</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val dsDF: DataFrame = dataS.toDF()</span><br><span class="line">dsDF.foreach(row =&gt; println(row.getString(0)+&quot; &quot;+row.getInt(1)))</span><br></pre></td></tr></table></figure><h3 id="udf与udaf"><a href="#udf与udaf" class="headerlink" title="udf与udaf"></a>udf与udaf</h3><ul><li>udf:用户自定义函数，单行函数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spark.udf.register(&quot;addName&quot;,(x:String)=&gt;(&quot;name:&quot;+x))</span><br><span class="line"></span><br><span class="line">spark.sql(&quot;select addName(name) as name from persion&quot;).show()</span><br></pre></td></tr></table></figure><ul><li>udaf：用户自定义聚集函数，多行函数，多对一</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class MyUdaf extends UserDefinedAggregateFunction&#123;</span><br><span class="line">   //输入值的类型</span><br><span class="line">  override def inputSchema: StructType = StructType(Seq(StructField(&quot;input&quot;,DoubleType)))</span><br><span class="line">  // 缓存的值的类型</span><br><span class="line">  override def bufferSchema: StructType = StructType(Seq(StructField(&quot;sum&quot;,DoubleType),StructField(&quot;count&quot;,IntegerType)))</span><br><span class="line">  //返回值的类型</span><br><span class="line">  override def dataType: DataType = DoubleType</span><br><span class="line"></span><br><span class="line">  override def deterministic: Boolean = true</span><br><span class="line">  //初始值</span><br><span class="line">  override def initialize(buffer: MutableAggregationBuffer): Unit = &#123;</span><br><span class="line">    buffer(0) = 0.0</span><br><span class="line">    buffer(1) = 0</span><br><span class="line">  &#125;</span><br><span class="line">  override def update(buffer: MutableAggregationBuffer, input: Row): Unit = &#123;</span><br><span class="line">    buffer(0) = buffer.getDouble(0)+input.getDouble(0)</span><br><span class="line">    buffer(1) = buffer.getInt(1)+1</span><br><span class="line">  &#125;</span><br><span class="line">  // 分区合并</span><br><span class="line">  override def merge(buffer1: MutableAggregationBuffer, buffer2: Row): Unit = &#123;</span><br><span class="line">    buffer1(0) = buffer1.getDouble(0)+buffer2.getDouble(0)</span><br><span class="line">    buffer1(1) = buffer1.getInt(1)+buffer2.getInt(1)</span><br><span class="line">  &#125;</span><br><span class="line">  // 结果</span><br><span class="line">  override def evaluate(buffer: Row): Double = &#123;</span><br><span class="line">    buffer.getDouble(0)/buffer.getInt(1)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">spark.udf.register(&quot;mu&quot;,new MyUdaf)</span><br><span class="line">spark.sql(&quot;select mu(age) from persion&quot;).show()</span><br></pre></td></tr></table></figure><h3 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> @Test</span><br><span class="line">  def test1(): Unit =&#123;</span><br><span class="line"></span><br><span class="line">    val spark = SparkSession.builder().appName(&quot;jdbc&quot;).master(&quot;local[*]&quot;).getOrCreate()</span><br><span class="line">    val properties = new Properties()</span><br><span class="line">    properties.setProperty(&quot;user&quot;,&quot;root&quot;)</span><br><span class="line">    properties.setProperty(&quot;password&quot;,&quot;husaijian123&quot;)</span><br><span class="line">    val jdbcDF= spark.read.jdbc(&quot;jdbc:mysql://localhost:3306/interview&quot;,&quot;student&quot;,properties)</span><br><span class="line">    jdbcDF.show()</span><br><span class="line"></span><br><span class="line">    val jdbcDF2 = spark.read.format(&quot;jdbc&quot;).</span><br><span class="line"> option(&quot;url&quot;,&quot;jdbc:mysql://localhost:3306/interview&quot;).option(&quot;dbtable&quot;,&quot;student&quot;).option(&quot;user&quot;,&quot;root&quot;).option(&quot;password&quot;,&quot;husaijian123&quot;).load()</span><br><span class="line">    jdbcDF2.show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Spark-Sql运行架构"><a href="#Spark-Sql运行架构" class="headerlink" title="Spark Sql运行架构"></a>Spark Sql运行架构</h3><p><img src="https://handerh-1259550163.cos.ap-shanghai.myqcloud.com/java/spark/spark_sql1.png" alt></p><ol><li>在解析Sql之前会创建SparkSession,SparkSession会将元数据保存到SessionCatelog,包括表名，字段名，字段类型。</li><li>使用SparkSqlParser进行解析SQL,构建语法树</li><li>使用分析器Analysiser绑定逻辑计划</li><li>使用优化器Optimizer优化逻辑计划</li><li>私用SparkPlanner生成物理计划</li><li>使用QueryExecution执行物理计划</li></ol><h3 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h3><p>窗口函数计算的一组行，被称为Frame。每一个被处理的行都有一个唯一的frame相关联。</p><p>窗口函数分为三类，ranking（排名），analystic（分析），aggregate（聚合）</p><table><thead><tr><th><strong>Function Type</strong></th><th><strong>SQL</strong></th><th><strong>DataFrame API</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td>Ranking</td><td>rank</td><td>rank</td><td>rank值可能是不连续的</td></tr><tr><td>Ranking</td><td>dense_rank</td><td>denseRank</td><td>rank值一定是连续的</td></tr><tr><td>Ranking</td><td>percent_rank</td><td>percentRank</td><td>相同的分组中 (rank -1) / ( count(score) - 1 )</td></tr><tr><td>Ranking</td><td>ntile</td><td>ntile</td><td>将同一组数据循环的往n个桶中放，返回对应的桶的index，index从1开始</td></tr><tr><td>Ranking</td><td>row_number</td><td>rowNumber</td><td>很单纯的行号，类似excel的行号</td></tr><tr><td>Analytic</td><td>cume_dist</td><td>cumeDist</td><td></td></tr><tr><td>Analytic</td><td>first_value</td><td>firstValue</td><td>相同的分组中第一个值</td></tr><tr><td>Analytic</td><td>last_value</td><td>lastValue</td><td>相同的分组中最后一个值</td></tr><tr><td>Analytic</td><td>lag</td><td>lag</td><td>取前n行数据</td></tr><tr><td>Analytic</td><td>lead</td><td>lead</td><td>取后n行数据</td></tr><tr><td>Aggregate</td><td>min</td><td>min</td><td>最小值</td></tr><tr><td>Aggregate</td><td>max</td><td>max</td><td>最大值</td></tr><tr><td>Aggregate</td><td>sum</td><td>sum</td><td>求和</td></tr><tr><td>Aggregate</td><td>avg</td><td>avg</td><td>求平均</td></tr></tbody></table><p>用法：函数名 over(分区 排序 范围)</p><p>当一个函数被窗口函数使用时，需要为该窗口函数定义相关的窗口规范,窗口规范包括三个部分</p><p>分区（PARTITION BY）</p><p>排序（order by)</p><p>帧规范：指定哪些行会被当前输入行的帧包括，通过其他行对于当前行的相对位置实现。定义帧规范需要定义帧的类型，开始边界，结束边界。一共有五种边界：UNBOUNDED PRECEDING(分区第一行)，UNBOUNDED FOLLOWING(分区最后一行)，CURRENT ROW，n PRECEDING(当前行的前n行）,n FOLLOWING(当前行后n行)。有两种帧类型：ROW帧和RANGE帧。</p><p>ROW帧是基于当前输入行的位置的物理偏移量,如：BETWEEN 1 PRECEDING AND 1 FOLLOWING表示一个包括当前行、当前行之前1行和之后1行的帧</p><p>RANGE帧是基于当前行位置的逻辑偏移。逻辑偏移为当前输入行的排序表达式的值和帧边界行的排序表达式的值之差。如：RANGE BETWEEN 2000 PRECEDING AND 1000 FOLLOWING，则边界为[current revenue value - 2000, current revenue value + 1000]。</p><ol><li>rank,dense_rank,percent_rank，row_number</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">## rank 排名时有重复，排序不连续，但是最大名次不变</span><br><span class="line">select id,name,classId,score, dense_rank() over(partition by classId order by score)rank from scores</span><br><span class="line"></span><br><span class="line">+---+-----+-------+-----+----+</span><br><span class="line">| id| name|classId|score|rank|</span><br><span class="line">+---+-----+-------+-----+----+</span><br><span class="line">|  3|张三3|      1| 79.0|   1|</span><br><span class="line">|  8|张三8|      1| 87.0|   2|</span><br><span class="line">|  1|张三1|      1| 88.0|   3|</span><br><span class="line">|  6|张三6|      1| 89.0|   4|</span><br><span class="line">|  4|张三4|      2| 78.0|   1|</span><br><span class="line">|  5|张三5|      2| 85.0|   2| </span><br><span class="line">|  2|张三2|      2| 85.0|   2|</span><br><span class="line">|  7|张三7|      2| 90.0|   4|</span><br><span class="line">+---+-----+-------+-----+----+</span><br><span class="line"></span><br><span class="line">## dense_rank 排名时有重复，排序连续，最大值减小</span><br><span class="line">select id,name,classId,score, dense_rank() over(partition by classId order by score)rank from scores</span><br><span class="line">+---+-----+-------+-----+----+</span><br><span class="line">| id| name|classId|score|rank|</span><br><span class="line">+---+-----+-------+-----+----+</span><br><span class="line">|  3|张三3|      1| 79.0|   1|</span><br><span class="line">|  8|张三8|      1| 87.0|   2|</span><br><span class="line">|  1|张三1|      1| 88.0|   3|</span><br><span class="line">|  6|张三6|      1| 89.0|   4|</span><br><span class="line">|  4|张三4|      2| 78.0|   1|</span><br><span class="line">|  5|张三5|      2| 85.0|   2|</span><br><span class="line">|  2|张三2|      2| 85.0|   2|</span><br><span class="line">|  7|张三7|      2| 90.0|   3|</span><br><span class="line">+---+-----+-------+-----+----+</span><br><span class="line"></span><br><span class="line">## percent_rank (rank -1) / ( count(score) - 1 )</span><br><span class="line">select id,name,classId,score, percent_rank() over(partition by classId order by score)rank from scores</span><br><span class="line">+---+-----+-------+-----+------------------+</span><br><span class="line">| id| name|classId|score|              rank|</span><br><span class="line">+---+-----+-------+-----+------------------+</span><br><span class="line">|  3|张三3|      1| 79.0|               0.0|</span><br><span class="line">|  8|张三8|      1| 87.0|0.3333333333333333|</span><br><span class="line">|  1|张三1|      1| 88.0|0.6666666666666666|</span><br><span class="line">|  6|张三6|      1| 89.0|               1.0|</span><br><span class="line">|  4|张三4|      2| 78.0|               0.0|</span><br><span class="line">|  5|张三5|      2| 85.0|0.3333333333333333|</span><br><span class="line">|  2|张三2|      2| 85.0|0.3333333333333333|</span><br><span class="line">|  7|张三7|      2| 90.0|               1.0|</span><br><span class="line">+---+-----+-------+-----+------------------+</span><br><span class="line">## row_number 按顺序排序 无重复排名</span><br><span class="line">select id,name,classId,score, row_number() over(partition by classId order by score)rank from scores</span><br><span class="line">---+-----+-------+-----+----+</span><br><span class="line">| id| name|classId|score|rank|</span><br><span class="line">+---+-----+-------+-----+----+</span><br><span class="line">|  3|张三3|      1| 79.0|   1|</span><br><span class="line">|  8|张三8|      1| 87.0|   2|</span><br><span class="line">|  1|张三1|      1| 88.0|   3|</span><br><span class="line">|  6|张三6|      1| 89.0|   4|</span><br><span class="line">|  4|张三4|      2| 78.0|   1|</span><br><span class="line">|  5|张三5|      2| 85.0|   2|</span><br><span class="line">|  2|张三2|      2| 85.0|   3|</span><br><span class="line">|  7|张三7|      2| 90.0|   4|</span><br><span class="line">+---+-----+-------+-----+----+</span><br></pre></td></tr></table></figure><ol start="2"><li>aggregate函数统计的结果在排序后的结果是不一样的</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">avg(score) over(partition by `) avg # 每个分组加起来求平均值</span><br><span class="line">avg(score) over(partition by classId order by score) # r1=r1 r2=(r1+r2)/2 ...</span><br><span class="line">avg(score) over(partition by classId  rows between 1 preceding and 1 following) avg_row  #当前行的前一行+当前行+后一行的平均值</span><br><span class="line">avg(score) over(partition by classId order by score range between 1 preceding and 1 following # score+(是否存在score+或-1)的平均值</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;spark-sql的概念&quot;&gt;&lt;a href=&quot;#spark-sql的概念&quot; class=&quot;headerlink&quot; title=&quot;spark sql的概念&quot;&gt;&lt;/a&gt;spark sql的概念&lt;/h3&gt;&lt;p&gt;spark sql是 是spark用来处理结构化数据的一个模块，提供了DataFrame和DataSet两个新的抽象概念。与RDD类似，DataSet和DataFrame都是分布式数据容器，DataFrame更像穿透数据库二维表格，除了记录数据之外，还记录数据的结构信息。DataFrame是Row对象的集合，而DataSet是DataFrame的一个扩展，DataSet每一个record存储的是一个强类型值而不是一个Row。RDD，DataSet和DataFram的共同点：三者都是分布式的弹性数据集，三者都有惰性机制，都有partition机制，有许多共同函数。三者可以相互转化&lt;/p&gt;
    
    </summary>
    
      <category term="spark" scheme="http://www.handerh.top/categories/spark/"/>
    
    
      <category term="spark" scheme="http://www.handerh.top/tags/spark/"/>
    
  </entry>
  
  <entry>
    <title>spark之RDD操作</title>
    <link href="http://www.handerh.top/2019/08/07/spark%E4%B9%8BRDD%E6%93%8D%E4%BD%9C/"/>
    <id>http://www.handerh.top/2019/08/07/spark之RDD操作/</id>
    <published>2019-08-07T07:44:39.000Z</published>
    <updated>2019-09-04T00:56:23.661Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-RDD的基本概念"><a href="#1-RDD的基本概念" class="headerlink" title="1. RDD的基本概念"></a>1. RDD的基本概念</h3><p>RDD是弹性分布式数据集,是spark中最基本的数据抽象，它代表一个可变，可分区的数据集合。在spark中对数据的所有操作包括创建 RDD、转化已有RDD 以及调用 RDD 操作进行求值。每个 RDD 都被分为多个分区，这些分区运行在集群中的不同节点上。</p><a id="more"></a><h4 id="RDD的属性"><a href="#RDD的属性" class="headerlink" title="RDD的属性"></a>RDD的属性</h4><ol><li>Partitions:一组分片，即数据集的基本组成单位.每个分片会被一个任务运行</li><li>Compute：分区计算函数</li><li>Dependencies:RDD的每次转换操作都会生成依赖关系，在部分分区数据丢失时，spark可以根据依赖关系恢复数据</li><li>Partitioner:RDD的分区方式，默认的是HashPartitoner,可以实现Partitioner自定义分区方式</li><li>preferred location:存储每个Partition位置的列表。</li></ol><h4 id="RDD的弹性"><a href="#RDD的弹性" class="headerlink" title="RDD的弹性"></a>RDD的弹性</h4><ol><li><p>自动进行内存和磁盘数据存储的切换</p><p>Spark优先把数据放到内存中，如果内存放不下，就会放到磁盘里面，程序进行自动的存储切换</p></li><li><p>基于血统的高效容错机制</p><p>在RDD进行转换和动作的时候，会形成RDD的Lineage依赖链，当某一个RDD失效的时候，可以通过重新计算上游的RDD来重新生成丢失的RDD数据。</p></li><li><p>Task失败进行特定次数的重试</p><p>RDD的计算任务如果运行失败，会自动进行任务的重新计算，默认次数是4次。</p></li><li><p>Stage如果失败会自动进行特定次数的重试</p><p>  如果Job的某个Stage阶段计算失败，框架也会自动进行任务的重新计算，默认次数也是4次</p></li><li><p>Checkpoint和Persist可主动或被动触发</p></li></ol><h3 id="２-RDD编程"><a href="#２-RDD编程" class="headerlink" title="２.RDD编程"></a>２.RDD编程</h3><h4 id="RDD创建"><a href="#RDD创建" class="headerlink" title="RDD创建"></a>RDD创建</h4><ol><li>从集合中创建</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val rdd1 = sc.parallelize(Array(1,2,3,4,5,6,7,8))</span><br><span class="line">这种方式默认分区个数使用的是　taskScheduler.defaultParallelism</span><br><span class="line">val rdd1 = sc.ｍakeRDD(Array(1,2,3,4,5,6,7,8))　// 调用的是上面的函数</span><br></pre></td></tr></table></figure><ol start="2"><li>从文件中创建</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> val rdd1  = sc.textFile(&quot;files/test&quot;)//math.min(defaultParallelism, 2)默认分区数</span><br><span class="line">// 获取的是每个文件的内容 key为文件名 value为文件内容</span><br><span class="line"> val rdd2: RDD[(String, String)] = sc.wholeTextFiles(&quot;files/test&quot;)</span><br></pre></td></tr></table></figure><h4 id="RDD的转换"><a href="#RDD的转换" class="headerlink" title="RDD的转换"></a>RDD的转换</h4><ol><li>mapPartitions:类似map,但是是基于分区执行的，有几个分区执行几次</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sc.parallelize(List((&quot;kpop&quot;,&quot;female&quot;),(&quot;zorro&quot;,&quot;male&quot;),(&quot;mobin&quot;,&quot;male&quot;))</span><br><span class="line">// mapPartition需要接受一个函数：f: Iterator[(String, String)] =&gt; Iterator[U]</span><br><span class="line">res10.mapPartitions(iter =&gt;Iterator(iter.mkString(&quot;|&quot;))).collect</span><br></pre></td></tr></table></figure><ol start="2"><li>glom：将每个分区中中的数据形成一个数组，形成一个数组类型的RDD</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val rdd1 = sc.parallelize(1 to 10,4)</span><br><span class="line">rdd1: org.apache.spark.rdd.RDD[Int] = ParallelCollectionRDD[0] at parallelize at &lt;console&gt;:24</span><br><span class="line"></span><br><span class="line">scala&gt; rdd1.glom.collect</span><br><span class="line">res0: Array[Array[Int]] = Array(Array(1, 2), Array(3, 4, 5), Array(6, 7), Array(8, 9, 10))</span><br><span class="line"></span><br><span class="line">scala&gt; rdd1.glom</span><br><span class="line">res1: org.apache.spark.rdd.RDD[Array[Int]] = MapPartitionsRDD[2] at glom at &lt;console&gt;:26</span><br></pre></td></tr></table></figure><ol start="3"><li>mapPartitionsWithIndex:比mapPartitions多了一个分区号</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rdd1.mapPartitionsWithIndex((x,y)=&gt;Iterator(x+&quot;:&quot;+y.mkString(&quot;|&quot;))）</span><br><span class="line">res4: org.apache.spark.rdd.RDD[String] = MapPartitionsRDD[1] at mapPartitionsWithIndex at &lt;console&gt;:26</span><br><span class="line"></span><br><span class="line">scala&gt; res4.collect</span><br><span class="line">res5: Array[String] = Array(0:(kpop,female), 1:(zorro,male)|(mobin,male))</span><br></pre></td></tr></table></figure><ol start="4"><li><p>sample(withReplacement: Boolean, fraction: Double,seed: Long = Utils.random.nextLong)</p><p>withReplacement表示抽出数据是否返回，fraction比例，seed随机的种子</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; rdd.sample(true,0.1,4).collect</span><br><span class="line">res10: Array[Int] = Array(4, 6)</span><br><span class="line"></span><br><span class="line">scala&gt; rdd.sample(true,0.2,4).collect</span><br><span class="line">res11: Array[Int] = Array(3, 5, 6)</span><br></pre></td></tr></table></figure><ol start="5"><li>partitionBy:分区，如果原有的partionRDD和现有的partionRDD是一致的话就不进行分区， 否则会生成ShuffleRDD。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">val rdd = sc.parallelize(Array((1,&quot;aaa&quot;),(2,&quot;bbb&quot;),(3,&quot;ccc&quot;),(4,&quot;ddd&quot;)),4)</span><br><span class="line">scala&gt; rdd.partitionBy(new org.apache.spark.HashPartitioner(2))</span><br><span class="line">res0: org.apache.spark.rdd.RDD[(Int, String)] = ShuffledRDD[1] at partitionBy at &lt;console&gt;:26</span><br><span class="line"></span><br><span class="line">scala&gt; res0.collect</span><br><span class="line">res1: Array[(Int, String)] = Array((2,bbb), (4,ddd), (1,aaa), (3,ccc))</span><br><span class="line"></span><br><span class="line">可以看到产生了ShuffledRDD，并且有四个分区变为两个</span><br></pre></td></tr></table></figure><ol start="6"><li>coalesce：根据分区数，重新进行分区，默认不进行shuffle</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val rdd = sc.parallelize(1 to 16,4)</span><br><span class="line">rdd.coalesce(3)</span><br><span class="line"></span><br><span class="line">scala&gt; res3.partitions.size  </span><br><span class="line">res6: Int = 3 </span><br><span class="line">分区个数变为三</span><br></pre></td></tr></table></figure><ol start="7"><li>repartition:底层调用coalesce(numPartitions, shuffle = true)，重分区使用shuffle</li><li>sortBy:先用函数对数据进行处理，再排序</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scala&gt;  val rdd = sc.parallelize(List(1,2,3,4))</span><br><span class="line">rdd: org.apache.spark.rdd.RDD[Int] = ParallelCollectionRDD[0] at parallelize at &lt;console&gt;:24</span><br><span class="line"></span><br><span class="line">scala&gt; rdd.sortBy(x=&gt;x%2)collect</span><br><span class="line">warning: there was one feature warning; re-run with -feature for details</span><br><span class="line">res0: Array[Int] = Array(2, 4, 1, 3)</span><br></pre></td></tr></table></figure><ol start="9"><li>join:在类型为(K,V)和(K,W)的RDD上调用，返回一个相同key对应的所有元素对在一起的(K,(V,W))的RDD</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val rdd = sc.parallelize(Array((1,&quot;a&quot;),(2,&quot;b&quot;),(3,&quot;c&quot;)))</span><br><span class="line">rdd: org.apache.spark.rdd.RDD[(Int, String)] = ParallelCollectionRDD[32] at parallelize at &lt;console&gt;:24</span><br><span class="line"></span><br><span class="line">scala&gt; val rdd1 = sc.parallelize(Array((1,4),(2,5),(3,6)))</span><br><span class="line">rdd1: org.apache.spark.rdd.RDD[(Int, Int)] = ParallelCollectionRDD[33] at parallelize at &lt;console&gt;:24</span><br><span class="line"></span><br><span class="line">scala&gt; rdd.join(rdd1).collect()</span><br><span class="line">res13: Array[(Int, (String, Int))] = Array((1,(a,4)), (2,(b,5)), (3,(c,6)))</span><br></pre></td></tr></table></figure><ol start="10"><li>cogroup:在类型为(K,V)和(K,W)的RDD上调用，返回一个(K,(Iterable<v>,Iterable<w>))类型的RDD</w></v></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val rdd = sc.parallelize(Array((1,&quot;a&quot;),(2,&quot;b&quot;),(3,&quot;c&quot;)))</span><br><span class="line">rdd: org.apache.spark.rdd.RDD[(Int, String)] = ParallelCollectionRDD[37] at parallelize at &lt;console&gt;:24</span><br><span class="line"></span><br><span class="line">scala&gt; val rdd1 = sc.parallelize(Array((1,4),(2,5),(3,6)))</span><br><span class="line">rdd1: org.apache.spark.rdd.RDD[(Int, Int)] = ParallelCollectionRDD[38] at parallelize at &lt;console&gt;:24</span><br><span class="line"></span><br><span class="line">scala&gt; rdd.cogroup(rdd1).collect()</span><br><span class="line">res14: Array[(Int, (Iterable[String], Iterable[Int]))] = Array((1,(CompactBuffer(a),CompactBuffer(4))), (2,(CompactBuffer(b),CompactBuffer(5))), (3,(CompactBuffer(c),CompactBuffer(6))))</span><br></pre></td></tr></table></figure><ol start="11"><li>reduceByKey</li></ol><p>在一个(K,V)的RDD上调用，返回一个(K,V)的RDD，使用指定的reduce函数，将相同key的值聚合到一起，reduce任务的个数可以通过第二个可选的参数来设置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val rdd = sc.parallelize(List((&quot;female&quot;,1),(&quot;male&quot;,5),(&quot;female&quot;,5),(&quot;male&quot;,2)))</span><br><span class="line">rdd.reduceByKey(_+_).collect</span><br><span class="line">res6: Array[(String, Int)] = Array((female,6), (male,7))</span><br></pre></td></tr></table></figure><p>12.groupByKey</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rdd.groupByKey() // 生成一个RDD[k,Iterator[t]]</span><br></pre></td></tr></table></figure><ol start="13"><li><p>combineByKey( createCombiner: V =&gt; C,  mergeValue: (C, V) =&gt; C,  mergeCombiners: (C, C) =&gt; C) createCombiner:分区内第一次碰到key，创建key对应C的初始值</p><p>mergeValue：第二次碰到key，将当前值与C中的值进行合并，分区内合并</p><p>mergeCombiners：由于每个分区是独立的，需要合并每个分区</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val scores: Array[(String, Int)] = Array((&quot;Fred&quot;,88), (&quot;Fred&quot;,95), (&quot;Fred&quot;,91), (&quot;Wilma&quot;,93), (&quot;Wilma&quot;,95), (&quot;Wilma&quot;,98))</span><br><span class="line">val input = sc.parallelize(scores)</span><br><span class="line">input.combineByKey(v=&gt;(v,1),(a:(Int,Int),b)=&gt;(a._1+b,a._2+1),(x:(Int,Int),y:(Int,Int))=&gt;(x._1+y._1,x._2+y._2))</span><br><span class="line"></span><br><span class="line">结果为 Array((Wilma,(286,3)), (Fred,(274,3)))</span><br></pre></td></tr></table></figure><ol start="13"><li><p>aggregateByKey(zeroValue:U,[partitioner: Partitioner]) (seqOp: (U, V) =&gt; U,combOp: (U, U) =&gt; U) </p><p>zeroValue：分区内的每个key对应的初始值U</p><p>seqOp：分区内的U的合并操作</p><p>combOp：每个分区的合并操作</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val scores: Array[(String, Int)] = Array((&quot;Fred&quot;,88), (&quot;Fred&quot;,95), (&quot;Fred&quot;,91), (&quot;Wilma&quot;,93), (&quot;Wilma&quot;,95), (&quot;Wilma&quot;,98))</span><br><span class="line">val input = sc.parallelize(scores)</span><br><span class="line">input.aggregateByKey((0,0))((a:(Int,Int),v:Int)=&gt;(a._1+v,a._2+1),(x,y)=&gt;(x._1+y._1,x._2+x._2))</span><br></pre></td></tr></table></figure><ol start="14"><li>foldByKey(zeroValue: V)(func: (V, V) =&gt; V): RDD[(K, V)] </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val rdd = sc.parallelize(List((1,3),(1,2),(1,4),(2,3),(3,6),(3,8)),3)</span><br><span class="line">dd.foldByKey(0)(_+_)</span><br><span class="line">// 结果</span><br><span class="line">res0.collect</span><br><span class="line">res1: Array[(Int, Int)] = Array((3,14), (1,9), (2,3))</span><br></pre></td></tr></table></figure><ol start="15"><li>sortByKey:在一个(K,V)的RDD上调用，K必须实现Ordered接口，返回一个按照key进行排序的(K,V)的RDD</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val rdd = sc.parallelize(Array((3,&quot;aa&quot;),(6,&quot;cc&quot;),(2,&quot;bb&quot;),(1,&quot;dd&quot;)))</span><br><span class="line">rdd.sortByKey()</span><br></pre></td></tr></table></figure><ol start="16"><li>mapValues:针对于(K,V)形式的类型只对V进行操作 </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val rdd3 = sc.parallelize(Array((1,&quot;a&quot;),(1,&quot;d&quot;),(2,&quot;b&quot;),(3,&quot;c&quot;)))</span><br><span class="line">rdd3.mapValues(a =&gt; a*2).collect</span><br><span class="line">结果： Array((1,aa), (1,dd), (2,bb), (3,cc))</span><br></pre></td></tr></table></figure><h4 id="RDD执行操作"><a href="#RDD执行操作" class="headerlink" title="RDD执行操作"></a>RDD执行操作</h4><ol><li>reduce（func)</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val rdd1 = sc.makeRDD(1 to 10,2)</span><br><span class="line">rdd1.reduce(_+_)</span><br></pre></td></tr></table></figure><ol start="2"><li>collect():在驱动程序中，以数组的形式返回数据集的所有元素</li><li>count():返回RDD的元素个数</li><li>first():返回RDD的第一个元素（类似于take(1)）</li><li>take(n):返回一个由数据集的前n个元素组成的数组</li><li>takeOrdered(n):返回前几个的排序</li><li>aggregate(zeroValue: U)(seqOp: (U, T) ⇒ U, combOp: (U, U) ⇒ U)</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; var rdd1 = sc.makeRDD(1 to 10,2)</span><br><span class="line">rdd1: org.apache.spark.rdd.RDD[Int] = ParallelCollectionRDD[88] at makeRDD at &lt;console&gt;:24</span><br><span class="line"></span><br><span class="line">scala&gt; rdd1.aggregate(1)(</span><br><span class="line">     | &#123;(x : Int,y : Int) =&gt; x + y&#125;,</span><br><span class="line">     | &#123;(a : Int,b : Int) =&gt; a + b&#125;</span><br><span class="line">     | )</span><br><span class="line">res56: Int = 58</span><br><span class="line"></span><br><span class="line">scala&gt; rdd1.aggregate(1)(</span><br><span class="line">     | &#123;(x : Int,y : Int) =&gt; x * y&#125;,</span><br><span class="line">     | &#123;(a : Int,b : Int) =&gt; a + b&#125;</span><br><span class="line">     | )</span><br><span class="line">res57: Int = 30361</span><br></pre></td></tr></table></figure><ol start="8"><li>folder(num)(func):折叠操作，aggregate的简化操作，seqop和combop一样。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; var rdd1 = sc.makeRDD(1 to 4,2)</span><br><span class="line">rdd1: org.apache.spark.rdd.RDD[Int] = ParallelCollectionRDD[90] at makeRDD at &lt;console&gt;:24</span><br><span class="line"></span><br><span class="line">scala&gt; rdd1.aggregate(1)(</span><br><span class="line">     | &#123;(x : Int,y : Int) =&gt; x + y&#125;,</span><br><span class="line">     | &#123;(a : Int,b : Int) =&gt; a + b&#125;</span><br><span class="line">     | )</span><br><span class="line">res59: Int = 13</span><br><span class="line"></span><br><span class="line">scala&gt; rdd1.fold(1)(_+_)</span><br><span class="line">res60: Int = 13</span><br></pre></td></tr></table></figure><ol start="9"><li><p>saveAsTextFile(path)</p><p>将数据集的元素以textfile的形式保存到HDFS文件系统或者其他支持的文件系统，对于每个元素，Spark将会调用toString方法，将它装换为文件中的文本</p></li><li><p>saveAsSequenceFile(path)</p><p>将数据集中的元素以Hadoop sequencefile的格式保存到指定的目录下，可以使HDFS或者其他Hadoop支持的文件系统</p></li><li><p>saveAsObjectFile(path)</p><p>用于将RDD中的元素序列化成对象，存储到文件中。</p></li><li><p>countByKey:针对(K,V)类型的RDD，返回一个(K,Int)的map，表示每一个key对应的元素个数。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val rdd = sc.parallelize(List((1,3),(1,2),(1,4),(2,3),(3,6),(3,8)),3)</span><br><span class="line">rdd: org.apache.spark.rdd.RDD[(Int, Int)] = ParallelCollectionRDD[95] at parallelize at &lt;console&gt;:24</span><br><span class="line"></span><br><span class="line">scala&gt; rdd.countByKey()</span><br><span class="line">res63: scala.collection.Map[Int,Long] = Map(3 -&gt; 2, 1 -&gt; 3, 2 -&gt; 1)</span><br></pre></td></tr></table></figure><ol start="13"><li>foreach</li></ol><h4 id="RDD的文件操作"><a href="#RDD的文件操作" class="headerlink" title="RDD的文件操作"></a>RDD的文件操作</h4><ul><li>saveAsObject File:底层调用其实是saveAsSequenceFile</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val rdd =  sc.parallelize(Array((&quot;zs&quot;,18),(&quot;lisi&quot;,20),(&quot;ww&quot;,17),(&quot;zl&quot;,30)))</span><br><span class="line"></span><br><span class="line">rdd.saveAsObjectFile(&quot;write_dile&quot;)</span><br><span class="line"></span><br><span class="line">val rdd2: RDD[(String, Int)] = sc.objectFile[(String,Int)](&quot;write_dile&quot;)</span><br></pre></td></tr></table></figure><ul><li>saveAsSequenceFile</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">al rdd =  sc.parallelize(Array((&quot;zs&quot;,18),(&quot;lisi&quot;,20),(&quot;ww&quot;,17),(&quot;zl&quot;,30)))</span><br><span class="line"></span><br><span class="line">rdd.saveAsSequenceFile(&quot;write_dile&quot;)</span><br><span class="line"></span><br><span class="line">val rdd2: RDD[(String, Int)] = sc.sequenceFile[String,Int](&quot;write_dile&quot;,classOf[String],classOf[Int])</span><br></pre></td></tr></table></figure><ul><li>hdfs</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val rdd =  sc.parallelize(Array((&quot;zs&quot;,18),(&quot;lisi&quot;,20),(&quot;ww&quot;,17),(&quot;zl&quot;,30)))</span><br><span class="line">  rdd.saveAsNewAPIHadoopFile(&quot;write_dile&quot;,classOf[Text],classOf[Text],classOf[TextOutputFormat[Text,Text]])</span><br><span class="line">  </span><br><span class="line">val rdd2 = sc.newAPIHadoopFile[Text,Text,KeyValueTextInputFormat](&quot;write_dile&quot;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-RDD的基本概念&quot;&gt;&lt;a href=&quot;#1-RDD的基本概念&quot; class=&quot;headerlink&quot; title=&quot;1. RDD的基本概念&quot;&gt;&lt;/a&gt;1. RDD的基本概念&lt;/h3&gt;&lt;p&gt;RDD是弹性分布式数据集,是spark中最基本的数据抽象，它代表一个可变，可分区的数据集合。在spark中对数据的所有操作包括创建 RDD、转化已有RDD 以及调用 RDD 操作进行求值。每个 RDD 都被分为多个分区，这些分区运行在集群中的不同节点上。&lt;/p&gt;
    
    </summary>
    
      <category term="spark" scheme="http://www.handerh.top/categories/spark/"/>
    
    
      <category term="spark" scheme="http://www.handerh.top/tags/spark/"/>
    
  </entry>
  
  <entry>
    <title>spark基本架构与运行原理</title>
    <link href="http://www.handerh.top/2019/08/05/spark%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/"/>
    <id>http://www.handerh.top/2019/08/05/spark基本架构与运行原理/</id>
    <published>2019-08-05T06:36:50.000Z</published>
    <updated>2019-09-04T00:56:48.125Z</updated>
    
    <content type="html"><![CDATA[<h3 id="spark运行架构图"><a href="#spark运行架构图" class="headerlink" title="spark运行架构图"></a>spark运行架构图</h3><p><img src="https://handerh-1259550163.cos.ap-shanghai.myqcloud.com/java/spark/spark1.png" alt></p><ul><li>Cluster Manager：在standalone模式中即为Master主节点，控制整个集群，监控worker。在YARN模式中为ResourceManager</li><li>Worker:从节点，负责控制计算节点，启动executor。在yarn集群中为nodemanager</li></ul><a id="more"></a><ul><li>Driver:运行Application的main函数并且创建SparkContext.</li><li>Executor:执行器,Application运行在worker节点上的一个进程，负责启动线程池运行任务(Task)</li><li>RDD DAG:RDD组成的有向无环图，反应RDD之间的依赖关系。当RDD遇到遇到Action算子的时候，将之前所有算子形成一个有向无环图</li><li>DAG Scheduler：根据job构造基于stage的DAG并将stage提交给TaskScheduler</li><li>TaskScheduler:将task任务分发给Executor执行</li><li>SparkEnv:线程级别的上下文，存储运行时中要组件的引用</li></ul><p><img src="https://handerh-1259550163.cos.ap-shanghai.myqcloud.com/java/spark/rdd.jpg" alt></p><h3 id="Spark作业基本概念"><a href="#Spark作业基本概念" class="headerlink" title="Spark作业基本概念"></a>Spark作业基本概念</h3><ul><li>Application:用户编写的Spark应用程序，其中包括一个Driver功能的代码和分布在集群中多个节点上运行的Executor代码</li><li>Driver Program:运行Application的main函数并且创建SparkContext</li><li>Job:一个RDD Graph 触发的作业，包含多个Task组成的并行计算</li><li>Stage:每个job会根据RDD的宽依赖关系切分成多个stage,每个stage包含一组相同的Task,也叫TaskSet</li><li>Task：被送到某个Executor上的工作单元，但hadoopMR中的MapTask和ReduceTask概念一样，是运行Application的基本单位，多个Task组成一个Stage，而Task的调度和管理等是由TaskScheduler负责</li></ul><h3 id="Spark运行机制"><a href="#Spark运行机制" class="headerlink" title="Spark运行机制"></a>Spark运行机制</h3><h4 id="spark运行流程"><a href="#spark运行流程" class="headerlink" title="spark运行流程"></a>spark运行流程</h4><p><img src="https://handerh-1259550163.cos.ap-shanghai.myqcloud.com/java/spark/spark3.png" alt></p><ol><li>用户在客户端将Application提交到ClusterManager</li><li>ClusterManager收到Application后，找一个worker启动Driver,初始化一个SparkContext.</li><li>SparkContext向资源管理器申请Executors,并启动StandaloneExecutorBackend</li><li>Executors向SparkContext申请Task,SparkContext中的DAG Scheduler会根据依赖关系拆分成多个stage,每个stage提交给一个Task Scheduler，Task Scheduler会将这些Task任务分发到Executor</li><li>Executor启动多线程，执行Task。</li><li>所有Task完成后，SparkContext向Master注销</li></ol><h3 id="Spark运行模式"><a href="#Spark运行模式" class="headerlink" title="Spark运行模式"></a>Spark运行模式</h3><ul><li>Standalone:Standalone模式使用Spark自带的资源调度框架,采用Master/Slaves的典型架构</li></ul><ol><li>用户在客户端将Application提交到ClusterManager</li><li>ClusterManager收到Application后，找一个worker启动Driver,初始化一个SparkContext.</li><li>SparkContext初始化时创建DAG Scheduler和Task Scheduler,向资源管理器申请Executors,并启动StandaloneExecutorBackend</li><li>Executors向SparkContext申请Task,SparkContext中的每一个DAG Scheduler会根据依赖关系拆分成多个stage,每个stage提交给一个Task Scheduler，Task Scheduler会将这些Task任务分发到Executor</li><li>Executor启动多线程，执行Task。</li><li>所有Task完成后，SparkContext向Master注销</li></ol><ul><li>Yarn Client:</li></ul><ol><li>Driver在本地提交任务的机器运行,Driver启动后向ResourceManager申请ApplicationMaster</li><li>ResourceManager找到一个NodeManager分配conainer,并且创建ApplicationMaster</li><li>AM创建后,向ResourceManager申请启动Executor,Executor启动后向Driver注册.</li><li>Driver注册完成后,Driver开始执行main方法,执行算子时,执行一个job,每个job会根据宽依赖划分为多个stage,每个stage,每个stage对应多个TaskSet,经过TaskSchedule分发到Executor执行.</li></ol><ul><li>Yarn Cluster</li></ul><ol><li>任务提交后,向ResourceManager申请ApplcationMaster</li><li>ResourceManager找到一个NodeManager分配conainer,并且创建ApplicationMaster,AM创建后,启动Driver,此时的AM就是一个Driver</li><li>AM向ResourceManager申请启动Executor,Executor启动后向Driver注册</li><li>Driver注册完成后,Driver开始执行main方法,执行算子时,执行一个job,每个job会根据宽依赖划分为多个stage,每个stage,每个stage对应多个TaskSet,经过TaskSchedule分发到Executor执行.</li></ol><h3 id="Spark-Shuffle阶段"><a href="#Spark-Shuffle阶段" class="headerlink" title="Spark Shuffle阶段"></a>Spark Shuffle阶段</h3><p>Spark Shuffle分为Map和Reduce阶段,它与stage阶段的划分有关,在一个job中如果碰到宽依赖,会被划分为多个stage,最终每个stage都会被划分为ResultStage和ShuffleMapStage,对应ReduceTask和ShuffleMapTask.ShuffleMapTask会根据partitioner对数据进行分组,并且进行持久化.</p><ul><li><p>未优化HashShuffle</p><p>HashShuffle在没有优化之前,每一个ShuffleMapTask会为每一个ReduceTask创建一个bucket(经过partitioner后对用的bucket),并且为每一个bucket创建一个文件.ReduceTask会去对应bucket中获取数据.但是这样有很大缺点就是生成的文件数量太多,这对于磁盘IO影响很大</p></li></ul><p><img src alt></p><ul><li><p>优化后的HashShuffle:</p><p>设置参数 spark.shuffle.consolidateFiles=true,在中间过程生成的文件数为cpu核数*reduceTask个数</p></li><li><p>Sorted-Based Shuffle:</p><ol><li><p>SortShuffleWriter运行机制:类似hadoop的shuffle过程,在ShuffleMapTask阶段,每个Task将所有数据写到一个文件中,并且生成一个索引文件.然后在由ReduceTask去文件中拉取对应分区的数据.</p></li><li><p>bypass运行机制:用于处理数据量小不需要排序和聚合的Shuffle操作</p><p>触发条件:1. shuffle map task的数量小于200(spark.shuffle.sort.bypassMergeThreshold )</p><p>​        2. 不是聚合类的shuffle算子</p></li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;spark运行架构图&quot;&gt;&lt;a href=&quot;#spark运行架构图&quot; class=&quot;headerlink&quot; title=&quot;spark运行架构图&quot;&gt;&lt;/a&gt;spark运行架构图&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://handerh-1259550163.cos.ap-shanghai.myqcloud.com/java/spark/spark1.png&quot; alt&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Cluster Manager：在standalone模式中即为Master主节点，控制整个集群，监控worker。在YARN模式中为ResourceManager&lt;/li&gt;
&lt;li&gt;Worker:从节点，负责控制计算节点，启动executor。在yarn集群中为nodemanager&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="spark" scheme="http://www.handerh.top/categories/spark/"/>
    
    
      <category term="spark" scheme="http://www.handerh.top/tags/spark/"/>
    
  </entry>
  
  <entry>
    <title>hadoop优化配置</title>
    <link href="http://www.handerh.top/2019/08/04/hadoop%E4%BC%98%E5%8C%96%E9%85%8D%E7%BD%AE/"/>
    <id>http://www.handerh.top/2019/08/04/hadoop优化配置/</id>
    <published>2019-08-04T07:08:41.000Z</published>
    <updated>2019-09-04T01:27:29.573Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-历史服务器的配置"><a href="#1-历史服务器的配置" class="headerlink" title="1. 历史服务器的配置"></a>1. 历史服务器的配置</h3><p>为了查看程序的历史运行情况，需要配置一下历史服务器。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> vi mapred-site.xml</span><br><span class="line"> &lt;!-- 历史服务器端地址 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;mapreduce.jobhistory.address&lt;/name&gt;</span><br><span class="line">&lt;value&gt;hadoop01:10020&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;!-- 历史服务器web端地址 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;mapreduce.jobhistory.webapp.address&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;hadoop01:19888&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure><p>启动历史服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mr-jobhistory-daemon.sh start historyserver</span><br></pre></td></tr></table></figure><p>查看JobHistory</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://hadoop01:19888/jobhistory</span><br></pre></td></tr></table></figure><h3 id="2-日志聚集"><a href="#2-日志聚集" class="headerlink" title="2.日志聚集"></a>2.日志聚集</h3><p>应用运行完成以后，将程序运行日志信息上传到HDFS系统上，可以方便的查看到程序运行详情，方便开发调试。开启日志聚集功能，需要重新启动NodeManager 、ResourceManager和HistoryManager。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vi yarn-site.xml</span><br><span class="line"></span><br><span class="line">&lt;!-- 日志聚集功能使能 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;yarn.log-aggregation-enable&lt;/name&gt;</span><br><span class="line">&lt;value&gt;true&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 日志保留时间设置7天 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;yarn.log-aggregation.retain-seconds&lt;/name&gt;</span><br><span class="line">&lt;value&gt;604800&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure><h3 id="3-默认的配置文件"><a href="#3-默认的配置文件" class="headerlink" title="3.默认的配置文件"></a>3.默认的配置文件</h3><table><thead><tr><th>要获取的默认文件</th><th>文件存放在Hadoop的jar包中的位置</th></tr></thead><tbody><tr><td>[core-default.xml]</td><td>hadoop-common-2.7.2.jar/ core-default.xml</td></tr><tr><td>[hdfs-default.xml]</td><td>hadoop-hdfs-2.7.2.jar/ hdfs-default.xml</td></tr><tr><td>[yarn-default.xml]</td><td>hadoop-yarn-common-2.7.2.jar/ yarn-default.xml</td></tr><tr><td>[mapred-default.xml]</td><td>hadoop-mapreduce-client-core-2.7.2.jar/ mapred-default.xml</td></tr></tbody></table><h3 id="4-CheckPoint时间设置"><a href="#4-CheckPoint时间设置" class="headerlink" title="4.CheckPoint时间设置"></a>4.CheckPoint时间设置</h3><p>通常情况下，SecondaryNameNode每隔一小时执行一次。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[hdfs-default.xml]</span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;dfs.namenode.checkpoint.period&lt;/name&gt;</span><br><span class="line">  &lt;value&gt;3600&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure><p>一分钟检查一次操作次数，当操作次数达到1百万时，SecondaryNameNode执行一次。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;dfs.namenode.checkpoint.txns&lt;/name&gt;</span><br><span class="line">  &lt;value&gt;1000000&lt;/value&gt;</span><br><span class="line">&lt;description&gt;操作动作次数&lt;/description&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;dfs.namenode.checkpoint.check.period&lt;/name&gt;</span><br><span class="line">  &lt;value&gt;60&lt;/value&gt;</span><br><span class="line">&lt;description&gt; 1分钟检查一次操作次数&lt;/description&gt;</span><br><span class="line">&lt;/property &gt;</span><br></pre></td></tr></table></figure><h3 id="5-namenode故障处理"><a href="#5-namenode故障处理" class="headerlink" title="5.namenode故障处理"></a>5.namenode故障处理</h3><p> 将SecondaryNameNode中数据拷贝到NameNode存储数据的目录；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 1. 删除NameNode存储的数据</span><br><span class="line">rm -rf /opt/module/hadoop/data/tmp/dfs/name/*</span><br><span class="line">// 2. 拷贝SecondaryNameNode中数据到原NameNode存储数据目录</span><br><span class="line">scp -r atguigu@hadoop104:/opt/module/hadoop/data/tmp/dfs/namesecondary/* ./name/</span><br></pre></td></tr></table></figure><h3 id="6-服役新节点"><a href="#6-服役新节点" class="headerlink" title="6.服役新节点"></a>6.服役新节点</h3><ol><li>克隆一台主机，配置ip和hostname</li><li>删除克隆后的主机的一些数据</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opt/module/hadoop/data和log）</span><br></pre></td></tr></table></figure><ol start="3"><li>启动datanode</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hadoop-daemon.sh start datanode</span><br><span class="line">yarn-daemin.sh start nodemanager</span><br><span class="line"></span><br><span class="line"># 如果数据不平衡 可以使用命令实现集群的再平衡</span><br><span class="line">start-balancer.sh</span><br></pre></td></tr></table></figure><h3 id="7-配置白名单"><a href="#7-配置白名单" class="headerlink" title="7.配置白名单"></a>7.配置白名单</h3><ol><li>在namenode的hadoop/etc/hadoop目录下新建dfs.hosts文件,添加主机名,添加到白名单的主机节点，都允许访问NameNode，不在白名单的主机节点，都会被退出。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hadoop01</span><br><span class="line">hadoop02</span><br><span class="line">hadoop03</span><br></pre></td></tr></table></figure><ol start="2"><li>在hdfs-site.xml配置文件中添加dfs.hosts属性</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;dfs.hosts&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;/opt/module/hadoop/etc/hadoop/dfs.hosts&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>刷新NameNode</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfsadmin -refreshNodes</span><br></pre></td></tr></table></figure><ol start="4"><li>更新ResourceManager节点</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn rmadmin -refreshNodes</span><br></pre></td></tr></table></figure><h3 id="8-配置黑名单"><a href="#8-配置黑名单" class="headerlink" title="8.配置黑名单"></a>8.配置黑名单</h3><ol><li>在namenode的hadoop/etc/hadoop目录下新建dfs.hosts.exclude文件，添加要退役主机名称</li><li>在NameNode的hdfs-site.xml配置文件中增加dfs.hosts.exclude属性</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;dfs.hosts.exclude&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;/opt/module/hadoop-2.7.2/etc/hadoop/dfs.hosts.exclude&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>刷新namenode,ResourceManager</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfsadmin -refreshNodes</span><br><span class="line">yarn rmadmin -refreshNodes</span><br></pre></td></tr></table></figure><ol start="4"><li>等到退役节点的数据块成功复制到其它节点，停止该节点</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hadoop-daemon.sh stop datanode</span><br><span class="line">yarn-daemon.sh stop nodemanager</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-历史服务器的配置&quot;&gt;&lt;a href=&quot;#1-历史服务器的配置&quot; class=&quot;headerlink&quot; title=&quot;1. 历史服务器的配置&quot;&gt;&lt;/a&gt;1. 历史服务器的配置&lt;/h3&gt;&lt;p&gt;为了查看程序的历史运行情况，需要配置一下历史服务器。&lt;/p&gt;
    
    </summary>
    
      <category term="hadoop" scheme="http://www.handerh.top/categories/hadoop/"/>
    
    
      <category term="hadoop" scheme="http://www.handerh.top/tags/hadoop/"/>
    
  </entry>
  
  <entry>
    <title>异常笔记</title>
    <link href="http://www.handerh.top/2019/08/02/%E5%BC%82%E5%B8%B8%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.handerh.top/2019/08/02/异常笔记/</id>
    <published>2019-08-02T06:28:17.000Z</published>
    <updated>2019-08-02T06:28:18.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>mysql</title>
    <link href="http://www.handerh.top/2019/07/29/mysql%E5%9F%BA%E7%A1%80/"/>
    <id>http://www.handerh.top/2019/07/29/mysql基础/</id>
    <published>2019-07-29T11:12:14.000Z</published>
    <updated>2019-07-31T08:39:50.116Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-mysql常见函数"><a href="#1-mysql常见函数" class="headerlink" title="1.mysql常见函数"></a>1.mysql常见函数</h2><h3 id="字符函数"><a href="#字符函数" class="headerlink" title="字符函数"></a>字符函数</h3><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">select length(str) # 获取长度</span><br><span class="line">select concat(str1,str2)　＃连接字符串</span><br><span class="line">select upper(str) </span><br><span class="line">select lower(str)</span><br><span class="line">select substring(str,start,len) # 截取字符串　下标从1开始</span><br><span class="line">select instr(pstr,cstr) # 返回子串第一次出现的索引</span><br><span class="line">select trim(&apos;a&apos; from &apos;aaaaaaaaaafaafaaa&apos;)# 指定去除两边的字符</span><br><span class="line">select lpad(str,len,s) # 用指定的字符实现左填充　len：总长度　str+s的长度</span><br><span class="line">select rpad(str,len,s) # 用指定的字符实现右填充　len：总长度　str+s的长度</span><br><span class="line">select replace(source,sourcestr,desstr) # 替换掉source中的sourcestr</span><br></pre></td></tr></table></figure><h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select round(1.65,1) # 四舍五入</span><br><span class="line">select ceil(1.3) # 2 向上取整　&gt;=1.3的最小整数</span><br><span class="line">select floor(9.9) # 向下取整　&lt;=9.9的最大整数</span><br><span class="line">select truncate(1.6899,2) # 截断</span><br><span class="line">select mod(a,b) # a-a/b*b 被除数为负，结果为负</span><br></pre></td></tr></table></figure><h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select NOW() #返回当前系统日期加时间</span><br><span class="line">select curdate()# 返回日期</span><br><span class="line">select curtime() # 返回时间</span><br><span class="line">select year(now())</span><br><span class="line">select month(now())</span><br><span class="line">select day(now())</span><br><span class="line">select str_to_date(&apos;2019-07-29&apos;,&apos;%Y-%c-%d&apos;) #将日期格式的字符串转换为日期</span><br><span class="line">select date_format() # 将日期转换为字符串 select date_format(now(),&apos;%y-%m-%d&apos;);</span><br></pre></td></tr></table></figure><p><img src="https://handerh-1259550163.cos.ap-shanghai.myqcloud.com/java/musql/mysql_date.png" alt></p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select version()</span><br><span class="line">select database()</span><br><span class="line">seelct user()</span><br><span class="line">show variables like &apos;%char%&apos;</span><br></pre></td></tr></table></figure><h3 id="流程控制函数"><a href="#流程控制函数" class="headerlink" title="流程控制函数"></a>流程控制函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># if</span><br><span class="line">select if(expr,true.false)</span><br><span class="line"># case函数的使用</span><br><span class="line">#1. switch case</span><br><span class="line">select </span><br><span class="line">case 要判断的字段或表达式</span><br><span class="line">when 常量1 then 要显示的值或语句</span><br><span class="line">when 常量2 then 要显示的值或语句</span><br><span class="line">else 要显示的值或语句</span><br><span class="line">end</span><br><span class="line">from table</span><br><span class="line">#2.多重if</span><br><span class="line">select </span><br><span class="line">case </span><br><span class="line">when expr then 要显示的值或语句</span><br><span class="line">when expr then 要显示的值或语句</span><br><span class="line">else 要显示的值或语句</span><br><span class="line">end</span><br><span class="line">from table</span><br></pre></td></tr></table></figure><h3 id="limit-分页"><a href="#limit-分页" class="headerlink" title="limit:分页"></a>limit:分页</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">limit offset,size # offset 要显示的条目的起始索引，从０开始，size要显示的条目个数</span><br></pre></td></tr></table></figure><h2 id="2-DDL"><a href="#2-DDL" class="headerlink" title="2.DDL"></a>2.DDL</h2><h3 id="库的管理"><a href="#库的管理" class="headerlink" title="库的管理"></a>库的管理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 库的创建</span><br><span class="line">create database if not exists dbname ;</span><br><span class="line"># 库的修改</span><br><span class="line">rename database oldname to newname;</span><br><span class="line">alter database dbname character set gbk</span><br><span class="line"># 库的删除</span><br><span class="line">drop database if exists dbname</span><br></pre></td></tr></table></figure><h3 id="表的管理"><a href="#表的管理" class="headerlink" title="表的管理"></a>表的管理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># 表的创建</span><br><span class="line">create table if not exists tname(</span><br><span class="line">列名 列的类型 约束</span><br><span class="line">列名 列的类型 约束</span><br><span class="line">....</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 表的修改</span><br><span class="line">#1. 修改列名</span><br><span class="line">alter table tname change column oldcol newcol dataType</span><br><span class="line">#2.修改列的类型或约束</span><br><span class="line">alter table tname modify column cloname newdataType</span><br><span class="line">#3.添加新列</span><br><span class="line">alter table tname add column newcol dataType;</span><br><span class="line">#4.删除列</span><br><span class="line">alter table tname drop column cloname</span><br><span class="line">#5.修改表名</span><br><span class="line">alter table tname rename to newtname</span><br><span class="line"></span><br><span class="line">#表的删除</span><br><span class="line">drop table if exists tname;</span><br><span class="line"></span><br><span class="line">#表的复制</span><br><span class="line"># 复制结构</span><br><span class="line">create table copy like tname</span><br><span class="line"># 结构+数据</span><br><span class="line">create table copy2</span><br><span class="line">select * from tname</span><br></pre></td></tr></table></figure><h3 id="常见约束"><a href="#常见约束" class="headerlink" title="常见约束"></a>常见约束</h3><ul><li>NOT NULL:字段不能为空</li><li>DEFAULT:用于保证该字段有默认值</li><li>PRIMARY KEY:主键约束，唯一不为空 </li><li>UNIQUE:唯一约束，可以为空</li><li>CHECK:检查约束 [mysql中不支持]</li><li>FOREIGN KEY :外键，用于限制两个表的关系</li></ul><p>列级约束：</p><p>​    六大约束语法都支持，但外键约束没效果</p><p>表级约束：</p><p>​    除了非空，默认，都支持</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># 添加表时添加约束</span><br><span class="line">create table stu(</span><br><span class="line">id int primary key,</span><br><span class="line">name varchar(20) not null,</span><br><span class="line">gender char(1) check(gender=&apos;男&apos; or gender=&apos;女&apos;),</span><br><span class="line">seat int unique ,</span><br><span class="line">majorid int foreign key references major(id)</span><br><span class="line">);</span><br><span class="line">create table major(</span><br><span class="line">id int primary key,</span><br><span class="line">majorName varchar(20)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 添加表级约束</span><br><span class="line">drop table if exists stu;</span><br><span class="line">create table stu(</span><br><span class="line">id int ,</span><br><span class="line">name varchar,</span><br><span class="line">gender char(1) ,</span><br><span class="line">seat int  ,</span><br><span class="line">majorid int,</span><br><span class="line">constraint pk primary key(id)</span><br><span class="line">constraint uq unique(seat)</span><br><span class="line">constraint ck check(gender=&apos;男&apos; or gender=&apos;女&apos;)</span><br><span class="line">constraint fk_stu_major froegin key(mojorid) references major(id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 修改表时添加约束 1</span><br><span class="line">alter table tname modify column colname dataType constraint</span><br><span class="line"></span><br><span class="line"># 修改表时添加约束 2</span><br><span class="line">alter table tname add [constraint name] 约束类型(字段名)</span><br><span class="line"></span><br><span class="line"># 修改表时删除约束</span><br><span class="line"># 非空约束和默认约束</span><br><span class="line">alter table tname modify column colname dataType；</span><br><span class="line"># 主键约束</span><br><span class="line">alter table tname drop primary key;</span><br><span class="line"># 唯一约束</span><br><span class="line">alter table tname drop index colname</span><br><span class="line"># 外键约束</span><br><span class="line">alter table tname drop foreign key colnames</span><br></pre></td></tr></table></figure><h2 id="3-视图"><a href="#3-视图" class="headerlink" title="3.视图"></a>3.视图</h2><p>一种虚拟存在的表，只保存sql逻辑，不保存查询结果，当多个地方用到同样的查询结果方便使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 视图的创建</span><br><span class="line">create view viewName</span><br><span class="line">as</span><br><span class="line">查询语句</span><br><span class="line">create view ct_view </span><br><span class="line">as </span><br><span class="line">select * from ct_call;</span><br><span class="line"></span><br><span class="line"># 视图的修改 </span><br><span class="line"># 1</span><br><span class="line">create or replace view viewName</span><br><span class="line">as</span><br><span class="line">查询语句</span><br><span class="line"># 2</span><br><span class="line">alter view viewName</span><br><span class="line">as</span><br><span class="line">查询语句</span><br><span class="line"></span><br><span class="line"># 视图的删除</span><br><span class="line">drop view viewName ...</span><br><span class="line"></span><br><span class="line"># 查看视图</span><br><span class="line">desc viewName;</span><br><span class="line">show create view viewName</span><br></pre></td></tr></table></figure><h2 id="4-变量"><a href="#4-变量" class="headerlink" title="4.变量"></a>4.变量</h2><p>系统变量：系统定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 查看所有系统变量</span><br><span class="line">show global | [session] variables;</span><br><span class="line"># 查看满足条件的系统变量</span><br><span class="line">show global | [session] variables like &apos;%char%&apos;;</span><br><span class="line"># 查看指定的某个系统变量的值</span><br><span class="line">select @@gloable|[session].系统变量名</span><br><span class="line">select @@tx_isolation;</span><br><span class="line"># 为某个系统变量复制</span><br><span class="line">set gloable|[session] 系统变量名 = value</span><br><span class="line">set @@gloable|[session].系统变量名 = value</span><br><span class="line"></span><br><span class="line">如果是全局级别需要加global,如果是session，可以不加，默认session</span><br></pre></td></tr></table></figure><p>自定义变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># 用户变量 （针对当前会话有效）</span><br><span class="line"># 1.声明并初始化 = 或 :=</span><br><span class="line">set @用户变量名=值</span><br><span class="line">set @用户变量名:=值 </span><br><span class="line">select @用户变量名:=值</span><br><span class="line"># 2. 赋值</span><br><span class="line">方式一：</span><br><span class="line">    set @用户变量名 =值</span><br><span class="line">    set @用户变量名:=值 </span><br><span class="line">    select @用户变量名:=值</span><br><span class="line">方式二:</span><br><span class="line">select 字段 into @用户变量名 from table</span><br><span class="line"># 3.使用（查看)</span><br><span class="line">select @用户变量名; </span><br><span class="line"></span><br><span class="line">#局部变量 （仅在begin end中有效)</span><br><span class="line"># 1.声明</span><br><span class="line">declare 变量名 类型;</span><br><span class="line">declare 变量名 类型 default value;</span><br><span class="line"># 2.赋值</span><br><span class="line">方式一：</span><br><span class="line">    set 局部变量名 =值</span><br><span class="line">    set 局部变量名:=值 </span><br><span class="line">    select @局部变量名:=值</span><br><span class="line">方式二:</span><br><span class="line">    select 字段 into 局部变量名 from table</span><br><span class="line"># 3.使用（查看)</span><br><span class="line">select @用户变量名;</span><br></pre></td></tr></table></figure><h2 id="5-存储过程和函数"><a href="#5-存储过程和函数" class="headerlink" title="5.存储过程和函数"></a>5.存储过程和函数</h2><h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><p>一组预先编译好的sql语句集，经编译后存储在数据库，用户只需要传递给定的参数和存储过程名，就可以调用。减少了编译次数并且减少了数据库服务的连接次数，提高了效率。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 创建语法</span><br><span class="line">create procedure 存储过程名(参数列表)</span><br><span class="line">begin</span><br><span class="line">一组合法的sql语句</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">参数列表：</span><br><span class="line">    参数模式 参数模式 参数类型</span><br><span class="line">        in stuname varchar(20)</span><br><span class="line">        参数模式：</span><br><span class="line">            in:该参数作为输入</span><br><span class="line">            out ：该参数作为返回值</span><br><span class="line">            inout：既可以作为输入又可以作为输出</span><br><span class="line">如果存储过程体只有一句话，begin end 可以省略,存储过程每天sql必须加;</span><br><span class="line">存储过程的结尾可以使用 delimiter 重新设置</span><br><span class="line">etc. delimiter 结束标志</span><br><span class="line"></span><br><span class="line"># 调用</span><br><span class="line">call 存储过程名(实参)</span><br><span class="line"></span><br><span class="line"># 删除</span><br><span class="line">drop procedure pname;&apos;</span><br><span class="line"></span><br><span class="line"># 查看</span><br><span class="line">show create procedure p1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># 例子</span><br><span class="line">delimitet $</span><br><span class="line"># 无参的存储过程</span><br><span class="line">create procedure p1()</span><br><span class="line">begin</span><br><span class="line">select * from ct_call;</span><br><span class="line">end$</span><br><span class="line">call p1()$</span><br><span class="line"></span><br><span class="line">#in</span><br><span class="line">create procedure p2(in cid int)</span><br><span class="line">begin</span><br><span class="line">select * from ct_call where id = cid;</span><br><span class="line">end$</span><br><span class="line">call p2(1)$</span><br><span class="line"></span><br><span class="line">#out</span><br><span class="line">create procedure p3(in cid int,out sum int)</span><br><span class="line">begin</span><br><span class="line">select sumCall into sum from ct_call where id = cid;</span><br><span class="line">end$</span><br><span class="line">call p3(1,@sum)$</span><br><span class="line">select @sum$</span><br><span class="line"></span><br><span class="line">#inout</span><br><span class="line">create procedure p4(inout a int,inout b int)</span><br><span class="line">begin</span><br><span class="line">set a=a*2;</span><br><span class="line">set b=b*2;</span><br><span class="line">end$</span><br><span class="line">set @a = 10$</span><br><span class="line">set @b = 20$</span><br><span class="line">p4(@a,@b)$</span><br><span class="line">call(@a,@b)</span><br><span class="line">select @a$</span><br><span class="line">select @b$</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>存储过程没有返回值，或者多个返回值，函数只有一个返回值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 创建</span><br><span class="line">create function 函数名(参数列表) returns 返回值类型</span><br><span class="line">begin</span><br><span class="line">函数体</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">参数列表：</span><br><span class="line">参数名 参数类型</span><br><span class="line">函数体:肯定会有return语句，如果没有则会报错</span><br><span class="line">如果return没有放在函数体的最后也不报错，但不建议</span><br><span class="line"></span><br><span class="line"># 调用 </span><br><span class="line">select 函数名(参数列表)</span><br><span class="line"></span><br><span class="line"># 查看</span><br><span class="line">show create function fname;</span><br><span class="line"></span><br><span class="line"># 删除 </span><br><span class="line">drop function fname;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 例子</span><br><span class="line"> create Function f1() returns int</span><br><span class="line">     begin</span><br><span class="line">     declare c int default 0;</span><br><span class="line">    select count(1) into c from ct_call;</span><br><span class="line">     return c;</span><br><span class="line">     end $</span><br><span class="line"> select f1()</span><br><span class="line"> </span><br><span class="line"> create Function f2(cid int) returns int</span><br><span class="line"> begin </span><br><span class="line"> declare sum int default 0;</span><br><span class="line"> select sumCal into sum from ct_call where id = cid;</span><br><span class="line"> return sum;</span><br><span class="line"> end $</span><br><span class="line"> select f2(1)</span><br></pre></td></tr></table></figure><h3 id="流程控制结构"><a href="#流程控制结构" class="headerlink" title="流程控制结构"></a>流程控制结构</h3><ul><li>分支结构</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># if</span><br><span class="line">if (表达式1，表达式2，表达式3) # 如果表达式1成立，返回表达式2的值，否则返回表达式3的值</span><br><span class="line"></span><br><span class="line">if 条件1 then 语句1；</span><br><span class="line">elseif 条件2 then 语句2;</span><br><span class="line">...</span><br><span class="line">end if;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># case</span><br><span class="line">case 变量|表达式|字段</span><br><span class="line">when 要判断的值 then 返回值1或语句；</span><br><span class="line">when 要判断的值 then 返回值2或语句;</span><br><span class="line">...</span><br><span class="line">else 返回值n</span><br><span class="line">end case;</span><br><span class="line"></span><br><span class="line">case </span><br><span class="line">when 要判断的条件1 then 返回值1或语句；</span><br><span class="line">when  要判断的条件2 then 返回值2或语句;</span><br><span class="line">...</span><br><span class="line">else 返回值n</span><br><span class="line">end case;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 例子</span><br><span class="line">#if</span><br><span class="line">create function f1(score int) returns char</span><br><span class="line">begin</span><br><span class="line">    if score&gt;80 then return &apos;A&apos;;</span><br><span class="line">    elseif score&lt;=80 then return &apos;B&apos;;</span><br><span class="line">    end if;</span><br><span class="line">end$</span><br><span class="line"></span><br><span class="line"># case</span><br><span class="line">create procedure p1(in score int)</span><br><span class="line">begin</span><br><span class="line">    case</span><br><span class="line">    when score&gt;80 then select &apos;A&apos;;</span><br><span class="line">    else select &apos;B&apos;;</span><br><span class="line">    end case;</span><br><span class="line">end $</span><br></pre></td></tr></table></figure><ul><li>循环结构</li></ul><p>三种循环while,loop,repeat， iterate类似continue,leave 类似break </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># while</span><br><span class="line">【标签：】while 循环条件 do</span><br><span class="line">循环体</span><br><span class="line">end while 【标签】</span><br><span class="line"></span><br><span class="line"># loop</span><br><span class="line">【标签：】loop</span><br><span class="line">循环体</span><br><span class="line">end loop 【标签】</span><br><span class="line"></span><br><span class="line"># repeat</span><br><span class="line">【标签：】repeat</span><br><span class="line">循环体</span><br><span class="line">until 结束循环的条件</span><br><span class="line">end repeat【标签】</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"># 例子</span><br><span class="line"># while</span><br><span class="line">create procedure p_w(in num int)</span><br><span class="line">begin</span><br><span class="line">declare i int default 1;</span><br><span class="line">while i&lt;num do</span><br><span class="line">        select * from ct_call where id = i;</span><br><span class="line">        set i = i+1;</span><br><span class="line">end while;</span><br><span class="line">end $</span><br><span class="line"></span><br><span class="line"># loop</span><br><span class="line">create procedure p_l(in num int)</span><br><span class="line">begin</span><br><span class="line">declare i int default 1;</span><br><span class="line">  l:loop</span><br><span class="line">  select * from ct_call where id = i;</span><br><span class="line">      set i = i+1;</span><br><span class="line">      if i&gt;10 then leave l;</span><br><span class="line">      end if;</span><br><span class="line">    end loop l;</span><br><span class="line">end$</span><br><span class="line"></span><br><span class="line"># repeat</span><br><span class="line">create procedure p_p(in num int)</span><br><span class="line">begin</span><br><span class="line">declare i int default 1;</span><br><span class="line">repeat</span><br><span class="line">        select * from ct_call where id = i;</span><br><span class="line">        set i = i+1;</span><br><span class="line">    until i&gt;10</span><br><span class="line">    end repeat;</span><br><span class="line">end$</span><br></pre></td></tr></table></figure><h2 id="6-行转列与列转行"><a href="#6-行转列与列转行" class="headerlink" title="6.行转列与列转行"></a>6.行转列与列转行</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `TEST_TB_GRADE` (</span><br><span class="line">  `ID` int(10) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `USER_NAME` varchar(20) DEFAULT NULL,</span><br><span class="line">  `COURSE` varchar(20) DEFAULT NULL,</span><br><span class="line">  `SCORE` float DEFAULT &apos;0&apos;,</span><br><span class="line">  PRIMARY KEY (`ID`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">insert into TEST_TB_GRADE(USER_NAME, COURSE, SCORE)  values</span><br><span class="line">(&quot;张三&quot;, &quot;数学&quot;, 34),</span><br><span class="line">(&quot;张三&quot;, &quot;语文&quot;, 58),</span><br><span class="line">(&quot;张三&quot;, &quot;英语&quot;, 58),</span><br><span class="line">(&quot;李四&quot;, &quot;数学&quot;, 45),</span><br><span class="line">(&quot;李四&quot;, &quot;语文&quot;, 87),</span><br><span class="line">(&quot;李四&quot;, &quot;英语&quot;, 45),</span><br><span class="line">(&quot;王五&quot;, &quot;数学&quot;, 76),</span><br><span class="line">(&quot;王五&quot;, &quot;语文&quot;, 34),</span><br><span class="line">(&quot;王五&quot;, &quot;英语&quot;, 89);</span><br><span class="line">+----+-----------+--------+-------+</span><br><span class="line">| ID | USER_NAME | COURSE | SCORE |</span><br><span class="line">+----+-----------+--------+-------+</span><br><span class="line">|  1 | 张三      | 数学   |    34 |</span><br><span class="line">|  2 | 张三      | 语文   |    58 |</span><br><span class="line">|  3 | 张三      | 英语   |    58 |</span><br><span class="line">|  4 | 李四      | 数学   |    45 |</span><br><span class="line">|  5 | 李四      | 语文   |    87 |</span><br><span class="line">|  6 | 李四      | 英语   |    45 |</span><br><span class="line">|  7 | 王五      | 数学   |    76 |</span><br><span class="line">|  8 | 王五      | 语文   |    34 |</span><br><span class="line">|  9 | 王五      | 英语   |    89 |</span><br><span class="line">+----+-----------+--------+-------+</span><br><span class="line"></span><br><span class="line">行转列:</span><br><span class="line">select USER_NAME,</span><br><span class="line">max(case course when &apos;语文&apos; then score else 0 end) &apos;语文&apos;,</span><br><span class="line">max(case course when &apos;数学&apos; then score else 0 end) &apos;数学&apos;,</span><br><span class="line">max(case course when &apos;英语&apos; then score else 0 end) &apos;英语&apos;</span><br><span class="line">from TEST_TB_GRADE</span><br><span class="line">group by USER_NAME;</span><br><span class="line">+-----------+--------+--------+--------+</span><br><span class="line">| USER_NAME | 语文   | 数学   | 英语   |</span><br><span class="line">+-----------+--------+--------+--------+</span><br><span class="line">| 张三      |     58 |     34 |     58 |</span><br><span class="line">| 李四      |     87 |     45 |     45 |</span><br><span class="line">| 王五      |     34 |     76 |     89 |</span><br><span class="line">+-----------+--------+--------+--------+</span><br><span class="line"></span><br><span class="line">列转行:</span><br><span class="line">create table test_tb_grade2 as</span><br><span class="line">(</span><br><span class="line">select USER_NAME,</span><br><span class="line">    max(case course when &apos;语文&apos; then score else 0 end) &apos;语文&apos;,</span><br><span class="line">    max(case course when &apos;数学&apos; then score else 0 end) &apos;数学&apos;,</span><br><span class="line">    max(case course when &apos;英语&apos; then score else 0 end) &apos;英语&apos;</span><br><span class="line">from TEST_TB_GRADE</span><br><span class="line">group by USER_NAME</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">select user_name,&apos;语文&apos;course,语文 as course from test_tb_grade2</span><br><span class="line">union select user_name,&apos;数学&apos;course,数学 as course from test_tb_grade2</span><br><span class="line">union select user_name,&apos;英语&apos;course,英语 as course from test_tb_grade2;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-mysql常见函数&quot;&gt;&lt;a href=&quot;#1-mysql常见函数&quot; class=&quot;headerlink&quot; title=&quot;1.mysql常见函数&quot;&gt;&lt;/a&gt;1.mysql常见函数&lt;/h2&gt;&lt;h3 id=&quot;字符函数&quot;&gt;&lt;a href=&quot;#字符函数&quot; class=&quot;headerlink&quot; title=&quot;字符函数&quot;&gt;&lt;/a&gt;字符函数&lt;/h3&gt;
    
    </summary>
    
      <category term="mysql" scheme="http://www.handerh.top/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://www.handerh.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>redis</title>
    <link href="http://www.handerh.top/2019/07/28/redis/"/>
    <id>http://www.handerh.top/2019/07/28/redis/</id>
    <published>2019-07-28T10:51:31.000Z</published>
    <updated>2019-08-02T01:02:43.581Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一.概述"></a>一.概述</h2><p>redis基于内存持久化，高性能的NoSql的key-value数据库.redis支持数据的持久化，可以将数据保存在磁盘中，重启时可以加载使用。redis持久化策略包括RDB,AOF。redis提供key-value类型的数据，同时还提供list,set,zset.hash类型的数据，redis单个key可存储512M大小，默认端口6379</p><a id="more"></a><h2 id="二-配置文件"><a href="#二-配置文件" class="headerlink" title="二.配置文件"></a>二.配置文件</h2><p>redis的配置文件为redis.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes # 以守护进程启动</span><br><span class="line">port 6379 # 指定端口</span><br><span class="line">bind 127.0.0.1 #绑定本机，只有本机可以访问</span><br><span class="line">databases 16 # 默认的数据库的个数</span><br><span class="line"># redis RDB持久化策略的持久化操作</span><br><span class="line">save 900 1 每900秒有一次更新操作，做持久化操作</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line">dbfilename dump.rdb # RDB持久化的镜像文件</span><br><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt; #主从复制</span><br><span class="line">requirepass foobared　#设置密码</span><br><span class="line">maxclients 10000 # 允许客户端连接的最大线程数</span><br><span class="line">maxmemory　&lt;bytes&gt;　＃指定redis最大内存限制</span><br><span class="line">appendonly no #指定是否在每次更新操作后进行日志记录，redis默认情况是异步的将数据写入磁盘 </span><br><span class="line">appendfilename &quot;appendonly.aof&quot;：# 指定更新日志文件名</span><br></pre></td></tr></table></figure><h2 id="三-数据类型"><a href="#三-数据类型" class="headerlink" title="三.数据类型"></a>三.数据类型</h2><ul><li>客户端启动和关闭</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h host -p port -a passwd</span><br><span class="line">redis-cli shutdown</span><br></pre></td></tr></table></figure><ul><li>string类型</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">set key val # 设置key和val</span><br><span class="line">exists key # 判断key是否存在</span><br><span class="line">expire key seceonds # 设置key的过期时间</span><br><span class="line">ttl key # 查看key的过期时间</span><br><span class="line">persist key # 移除过期时间</span><br><span class="line">rename key newkey # 修改key的名字</span><br><span class="line">move key db # 将key移动到指定数据库</span><br><span class="line">type key # 查看key的数据类型</span><br><span class="line">strlen key # 查看key的长度</span><br><span class="line">setnx key val # 如果key不存在，则创建</span><br><span class="line">getrange key start end # 获取key的指定字符串</span><br><span class="line">incr key# 自增</span><br><span class="line">incrby key num # 自增num</span><br><span class="line">decr key # 自减</span><br><span class="line">decrby key num # 自减num</span><br></pre></td></tr></table></figure><p>应用场景:计数，微博数，粉丝数</p><ul><li>hash类型:string类型的field和value映射表，可以用来存储java对象,内部实际是一个hashmap，每个 hash 可以存储 232 -1 键值对</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hset key field value　# 设置key value</span><br><span class="line">hget key field #  获取 value</span><br><span class="line">hmset key f1 v1 f2 v2　＃　设置多个值</span><br><span class="line">hgetall key 　＃　获取hash表中key的所有字段</span><br><span class="line">hkeys key 获取hash表中key的所有字段</span><br><span class="line">hlen key 获取hash表中key的字段数</span><br><span class="line">hdel key field1 field2　＃　删除key中的属性</span><br><span class="line">hsetnx key field value　# 如果key不存在，则创建</span><br><span class="line">hincrby key field num  # 自增num </span><br><span class="line">hincrbyfloat key field num # 自增num </span><br><span class="line">hexists key field # 判断key中的属性是否存在</span><br></pre></td></tr></table></figure><p>应用场景：存储对象</p><ul><li>list类型：列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边），list是一个双向链表。列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">lpush key v1 v1 v3... #将一个或多个值插入列表头部</span><br><span class="line">rpush key v1 v2 v3... #将一个或多个值插入列表尾部</span><br><span class="line">lpushx key value #将一个值插入到已存在的列表头部，如果列表不存在，操作无效</span><br><span class="line">rpushx key value #将一个值插入到已存在的列表尾部，如果列表不存在，操作无效</span><br><span class="line">llen key //获取列表长度</span><br><span class="line">lindex key index //通过索引获取列表中的元素</span><br><span class="line">lrange key start stop //获取列表指定范围的元素</span><br><span class="line">lpop key 从左删除</span><br><span class="line">rpop key 从右删除</span><br><span class="line">blpop key timeout 移除并且获取列表第一个元素，如果列表没有元素会阻塞列表直到等待超时或发现可弹出数据为止</span><br><span class="line">brpop key timeout　移除并且获取列表最后一个元素，如果列表没有元素会阻塞列表直到等待超时或发现可弹出数据为止</span><br><span class="line">ltrim start end 保留指定下标的数据</span><br></pre></td></tr></table></figure><p>应用场景：twitter的关注列表，粉丝列表，消息队列</p><ul><li>set:集合是通过hashtable实现的，概念和数学中的集合基本类似，可以交集，并集，差集等等，set中的元素是没有顺序的。所以添加，删除，查找的复杂度都是O(1)。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sadd key v1 v2 ...</span><br><span class="line">scard key 获取集合的成员数</span><br><span class="line">smembers key 返回集合中的所有成员</span><br><span class="line">sismember key member 判断member是不是集合key的成员</span><br><span class="line">srandmember key [count] 返回集合中一个或多个随机数</span><br><span class="line">srem key member1 member2...　移除集合一个或多个 成员</span><br><span class="line">smove source dest member将member元素从source移动到destnation集合</span><br><span class="line">sdiff k1 k2 返回给定集合的差集</span><br><span class="line">sdiffstore k12 k1 k2  将k1 k2的差集存储在k12</span><br><span class="line">sinter  k1 k2 交集</span><br><span class="line">sinterstore k12  k1 k2 将k1 k2的交集存储在k12</span><br><span class="line">sunion  k1 k2 并集</span><br><span class="line">sunionstore k12 k1 k2   将k1 k2的并集存储在k12</span><br></pre></td></tr></table></figure><p>应用场景:存储一个列表数据，不希望有重复值。set具有求交集，差集，并集的功能，方便实现共同关注，共同好友</p><ul><li>sorted set(zset):有序集合,存储的也是string类型元素的集合，不允许有重复的成员，每个元素都会关联一个double类型的分数，redis通过分数为集合中的成员进行从小到大的排序,有序集合的成员是唯一的，但是分数可以重复，集合是通过hash来实现的，添加查找删除的时间复杂度都是1.<br>集合中最大成员数为2的32次方减1</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">zadd key score1 member1 score2 member2 添加多个成员</span><br><span class="line">zcard key 获取有序集合的成员数</span><br><span class="line">zcount key min max 返回有序集合指定期间分数的成员数</span><br><span class="line">zrank key member 返回有序集合中指定成员的索引</span><br><span class="line">zrange key start stop [withscores] 通过索引区间返回有序集合指定区间内的成员</span><br><span class="line">zrevrange key start stop [withscores] 通过索引区间返回有序集合指定区间内的成员，分数有高到低、</span><br><span class="line">zrem key member [member] 移除集合中一个或多个成员</span><br><span class="line">zremrangebyrank key start stop 移除有序集合给定的排名区间所有成员</span><br><span class="line">zremrangebyrange　key min max 移除有序集合中给定的分数区间的所有成员</span><br></pre></td></tr></table></figure><p>应用场景：排行榜，带权重的消息队列</p><ul><li>flush</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flushdb 清除当前数据库所有的key</span><br><span class="line">flushall 清除整个redis的数据库所有key</span><br></pre></td></tr></table></figure><h2 id="四-发布订阅"><a href="#四-发布订阅" class="headerlink" title="四.发布订阅"></a>四.发布订阅</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">subscribe channel [channel]　 订阅某个频道</span><br><span class="line">psubscribe pattern [pattern] 订阅一个或多个符合指定模式的频道</span><br><span class="line">publish channel message</span><br><span class="line">unsubscribe channel [channel] 退订频道</span><br><span class="line">punsubscribe pattern [pattern] 退订所有给定模式的频道</span><br></pre></td></tr></table></figure><p>应用场景：构建实时消息系统，比如即时聊天，群聊，博客，公众号</p><h2 id="五事物"><a href="#五事物" class="headerlink" title="五事物"></a>五事物</h2><p>redis批量操作在exex之前，被放入到队列缓存，收到exec命令后进入事物执行。如果事物中有任意命令执行失败，其它命令依然被执行.redis会将一个事物中的所有命令序列化，然后按顺序执行，执行过程中不会被其他命令插入.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">multi:标记一个事物的开始</span><br><span class="line">exec:执行命令</span><br><span class="line">discard 取消事物，放弃执行事物块内的所有命令</span><br><span class="line">watch:监视一个或多个key watch key [key]如果在事物执行之前这个key被其它命令所改动，那么事物将被打断</span><br><span class="line">unwatch:取消watch命令对key的监视</span><br></pre></td></tr></table></figure><p>如果执行的某个命令报错，则只有报错的命令不会被执行，其它的命令会被执行<br>回滚：当队列中的某个命令出现报告错误，执行时整个队列的命令都被取消</p><h2 id="六-redis持久化"><a href="#六-redis持久化" class="headerlink" title="六.redis持久化"></a>六.redis持久化</h2><p>redis数据存放在内存(高效，断电数据会丢失)当内存不足时，redis会根据配置的缓存策略淘汰部分key<br>以保证写入成功，当无淘汰策略时或没有找到合适的key时，redis直接返回out of memory</p><p>淘汰策略</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在redis中，允许用户设置最大使用内存大小　maxmemory 512G</span><br><span class="line">volatile-lru:从已设置过期时间的数据中挑选最近最少使用的数据淘汰</span><br><span class="line">volatile-lfu:从已设置过期时间的数据中，删除一段时间内使用次数最少</span><br><span class="line">volatile-ttl：从已设置过期时间的数据中,挑选最近要过期的</span><br><span class="line">volatile-random:从已设置过期时间的数据中随机淘汰一些数据</span><br><span class="line">allkeys-lru:从数据集中挑选最近最少使用的数据淘汰</span><br><span class="line">allkeys-lfu:从所有keys中，删除一段时间内最少使用的数据</span><br><span class="line">allkeys-random:从数据集中随机选择数据淘汰</span><br><span class="line">no-enviction(驱逐):禁止驱逐数据，不采用任何淘汰算法。默认的设置</span><br></pre></td></tr></table></figure><p>redis持久化机制</p><ul><li><p>rdb:是redis的默认持久化机制，rdb相当于快照，保存的是一种状态.将内存中的数据一快照的方式写入到二进制文件中去，默认为dump.rdb</p><p> 优点：快照保存数据极快，还原数据极快，适用于灾难备份</p></li><li><p>AOF(Append-only file):由于快照方式是在一定时间间隔，所有如果redis以为down掉的话，就会丢失最后一次快照后的所有修改，如果要求不能丢失任何修改的化，可以采用aof持久化方式.aof持久化方式:将每一个写命令都通过write函数追加到文件（appendonly.aof),当redis重启时会通过执行文件中的保存的写命令在内存中重建整个数据库.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes # 开启AOF</span><br><span class="line"># appendfsync always 收到写命令立即写入到磁盘，最慢，但是保证完全的持久化　</span><br><span class="line">appendfsync everysec　每秒钟写入到磁盘一次</span><br><span class="line"># appendfsync no    完全依赖os，性能好，持久化没保证</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一.概述&quot;&gt;&lt;/a&gt;一.概述&lt;/h2&gt;&lt;p&gt;redis基于内存持久化，高性能的NoSql的key-value数据库.redis支持数据的持久化，可以将数据保存在磁盘中，重启时可以加载使用。redis持久化策略包括RDB,AOF。redis提供key-value类型的数据，同时还提供list,set,zset.hash类型的数据，redis单个key可存储512M大小，默认端口6379&lt;/p&gt;
    
    </summary>
    
      <category term="redis" scheme="http://www.handerh.top/categories/redis/"/>
    
    
      <category term="redis" scheme="http://www.handerh.top/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>通信分析项目总结</title>
    <link href="http://www.handerh.top/2019/07/24/%E9%80%9A%E4%BF%A1%E5%88%86%E6%9E%90%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    <id>http://www.handerh.top/2019/07/24/通信分析项目总结/</id>
    <published>2019-07-24T14:10:43.000Z</published>
    <updated>2019-07-28T10:52:26.908Z</updated>
    
    <content type="html"><![CDATA[<p>该项目是基于通话日志的分析，当前每时每刻都有很多人打电话，那么产生的通话记录也是一个非常大数据量，需求就是根据这个通话日志，统计出每天，每月，每年用户的通话次数以及通话时长。</p><a id="more"></a><p>项目架构</p><p><img src="https://handerh-1259550163.cos.ap-shanghai.myqcloud.com/java/project/calllog.png" alt></p><p>项目中遇到的困难</p><ol><li>数据格式转化有点麻烦</li></ol><p>随机产生通话日志，要求数据遵循的格式一致，用到了一个新的api DecimalFormat，DecimalFormat主要是将数字格式化，它拥有两种占位符0 #</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 0 的用法</span><br><span class="line">//１．情况一　如果0的位数比要格式化的数字位数多 会在不足的位置用０补充</span><br><span class="line">new DecimalFormat(“00.00”).format(3.14) //结果：03.14 </span><br><span class="line">//２．情况二　如果0的位数比要格式化的数字位数少 整数位不变，小数部分四舍五入</span><br><span class="line">new DecimalFormat(“0.00”).format(13.146) //结果：13.15 </span><br><span class="line"></span><br><span class="line">// # 的用法</span><br><span class="line">//１．情况一　如果#的位数比要格式化的数字位数多 不变</span><br><span class="line">new DecimalFormat(“##.###”).format(3.14) //结果：3.14 </span><br><span class="line">//２．情况二　如果＃的位数比要格式化的数字位数少 整数位不变，小数部分四舍五入</span><br><span class="line">new DecimalFormat(“#.##”).format(13.146) //结果：13.15</span><br></pre></td></tr></table></figure><ol start="2"><li>hbase预分区以及rowkey的设计</li></ol><p>hbase建表时默认只有一个分区，所有数据都会写入到该分区，当数据越来越多时，region会进行split,分成两个reigon,之后，数据写入时会一直往一个region中写入数据，会造成数据热点问题，还有region进行split会消耗集群的io资源，所以需要进行预分区，控制数据的写入，在这个项目中，我总共分了6个分区，分区键为　0|, 1|, 2|, 3|, 4|, 5|.这样，在我往hbase插入数据的时候，就能有效的控制分区了。</p><p>为了能够将数据随机插入到给个分区，rowKey设计至关重要，基于分区键的设计，rowkey需要以0<del>5这样的数字开头，所以为了可以能够随机的将数据插入到各个分区，在这里，使用了tel和date的hashcode的值，在对分区数进行取模，得到的是0</del>5的数字，这样就能够保证数据可以有效的插入到各个分区。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * rowKey的设计</span><br><span class="line">    *  1.长度原则：最大　64kb 推荐10-100byte,最好是8的倍数</span><br><span class="line">    *              rowKey如果太长，影响性能</span><br><span class="line">    *                  原因：rowKey如果太长，会占用MemStore,减少缓存的数据</span><br><span class="line">    *  2.唯一原则:</span><br><span class="line">    *  3.散列原则：</span><br><span class="line">    *      盐值散列：不能使用时间戳，在时间戳前面增加一些随机数</span><br><span class="line">    *      字符串反转（时间戳，电话号码）</span><br><span class="line">    *      计算分区号</span><br><span class="line">    */</span><br></pre></td></tr></table></figure><p>3.mysql表的设计</p><p>设计了三张表，用户表，日期表，通话日志表</p><p>用户表记录用户名　用户电话　</p><p>日期表记录日期,包括xxxx年　xxxx年xx月 xxxx年xx月xx日，三种类型的日期，方便进行统计</p><p>通话日志表有两个外键，一个外键指向用户表，主要是用于获取电话号码，一个外键指向日期表，用于获取具体的日期。</p><p>当时是用一张表来解决的，将电话号码和日期都存在通话日志表中，后来看表中数据的时候感觉冗余数据太多，考虑将表拆分。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;该项目是基于通话日志的分析，当前每时每刻都有很多人打电话，那么产生的通话记录也是一个非常大数据量，需求就是根据这个通话日志，统计出每天，每月，每年用户的通话次数以及通话时长。&lt;/p&gt;
    
    </summary>
    
      <category term="项目总结" scheme="http://www.handerh.top/categories/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="项目总结" scheme="http://www.handerh.top/tags/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>scala</title>
    <link href="http://www.handerh.top/2019/07/22/scala/"/>
    <id>http://www.handerh.top/2019/07/22/scala/</id>
    <published>2019-07-22T06:46:09.000Z</published>
    <updated>2019-08-02T09:31:34.267Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-变量"><a href="#一-变量" class="headerlink" title="一.变量"></a>一.变量</h2><h3 id="scala的数据类型"><a href="#scala的数据类型" class="headerlink" title="scala的数据类型"></a>scala的数据类型</h3><a id="more"></a><p><img src="https://handerh-1259550163.cos.ap-shanghai.myqcloud.com/java/scala/scala1.png" alt></p><ul><li><p>Any:根类型，所有类的父类，它有两个直接子类，AnyValue,AnyRef</p></li><li><p>AnyRef:所有Scala中引用类（reference class)的父类</p></li><li><p>Null:所有引用类的子类，类似与java中的null</p></li><li><p>Nothing:所有类的子类，可以将Nothing类型的值返回给任意变量或者函数</p><h4 id="数据类型列表"><a href="#数据类型列表" class="headerlink" title="数据类型列表"></a>数据类型列表</h4><p><img src="https://handerh-1259550163.cos.ap-shanghai.myqcloud.com/java/scala/scala2.png" alt></p></li></ul><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">规则:</span><br><span class="line">val/var vname:type = value</span><br><span class="line">var i //error 变量声明必须初始化</span><br><span class="line">var x = _//error 需要明确具体的类型</span><br><span class="line">val y = _ //error val不可变，需要确定的值</span><br><span class="line">var i:int = 10</span><br><span class="line">val j:Char = &apos;a&apos;</span><br></pre></td></tr></table></figure><p>var和val的区别：</p><p>var修饰的变量是可变的，val修饰的变量是不可变的，它底层其实是使用final关键字修饰</p><h4 id="键盘输入语句"><a href="#键盘输入语句" class="headerlink" title="键盘输入语句"></a>键盘输入语句</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">println(&quot;请输入你的姓名&quot;)</span><br><span class="line">var name = StdIn.readLine()</span><br><span class="line"></span><br><span class="line">println(&quot;请输入你的证件号&quot;)</span><br><span class="line">var card = StdIn.readLine();</span><br></pre></td></tr></table></figure><h2 id="二-程序流程控制"><a href="#二-程序流程控制" class="headerlink" title="二.程序流程控制"></a>二.程序流程控制</h2><h3 id="1-if-else"><a href="#1-if-else" class="headerlink" title="1. if-else"></a>1. if-else</h3><p>与java中的if-else 差不多</p><h3 id="2-for循环控制"><a href="#2-for循环控制" class="headerlink" title="2.for循环控制"></a>2.for循环控制</h3><p>Scala为for循环这一常见的控制结果提供了非常多的特性，这些特性被成为for推导式或or表达式</p><ul><li>范围数据循环方式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//两边都是闭合的　</span><br><span class="line">for(i&lt;-start to end)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">//左闭右开</span><br><span class="line">for(i&lt;-start until end)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">//对集合进行循环遍历</span><br><span class="line">var list = List(&quot;hello&quot;,&quot;world&quot;,&quot;good&quot;)</span><br><span class="line">for (i&lt;-list)&#123;</span><br><span class="line">  println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>循环守卫</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> //条件为true的进入循环体内部　为false的则不进入</span><br><span class="line"> for (i&lt;-1 to 10 if i%2!=0 )&#123;</span><br><span class="line">      println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>引入变量</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> for (i&lt;-1 to 10;j = 10-i )&#123;</span><br><span class="line">      println(i+&quot;:&quot;+j)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>嵌套循环</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> //嵌套循环</span><br><span class="line">   for (i&lt;-1 to 3;j&lt;-1 to 3)&#123;</span><br><span class="line">     println(&quot;xxx&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>for 推倒　yield将结果收集</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//y 是一个Vector集合　Vector(1, 2, 3)</span><br><span class="line">val y = for (i&lt;-1 to 3) yield i</span><br><span class="line"> println(y)</span><br></pre></td></tr></table></figure><ul><li>使用花括号</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for &#123;</span><br><span class="line">         i&lt;-1 to 3 </span><br><span class="line">         j&lt;-1 to 3</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">      println(&quot;xxx&quot;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>控制步长</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//使用range控制for循环的步长</span><br><span class="line">    var range = new Range(1,10,2)</span><br><span class="line">    for (i&lt;- range)&#123;</span><br><span class="line">      println(i)</span><br><span class="line">    &#125;</span><br><span class="line">    for (i&lt;-1 to 10 if i % 2 == 1)&#123;</span><br><span class="line">      println(i)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="3-while循环控制"><a href="#3-while循环控制" class="headerlink" title="3.while循环控制"></a>3.while循环控制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">while()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">do&#123;</span><br><span class="line">    </span><br><span class="line">&#125;while()</span><br><span class="line"></span><br><span class="line">两者区别:while先进行判断再执行　do while 先执行再判断</span><br></pre></td></tr></table></figure><p>循环中断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var  i =1;</span><br><span class="line">    breakable&#123;</span><br><span class="line">      while (i&lt;20)&#123;</span><br><span class="line">        println(i)</span><br><span class="line">        if(i%4==0)&#123;</span><br><span class="line">          break;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">//需要导包　import util.control.Breaks._</span><br></pre></td></tr></table></figure><h3 id="4-异常处理"><a href="#4-异常处理" class="headerlink" title="4.异常处理"></a>4.异常处理</h3><ol><li>在scala中只有一个catch,但是有多个case，每个case可以用来匹配一种异常</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">        val i = 10/0;</span><br><span class="line">    &#125;catch&#123;</span><br><span class="line">      case exception: ArithmeticException =&gt;&#123;</span><br><span class="line">        println(&quot;出现除0异常&quot;)</span><br><span class="line">      &#125;</span><br><span class="line">      case exception: NullPointerException =&gt;&#123;</span><br><span class="line">        println(&quot;空指针异常&quot;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;finally &#123;</span><br><span class="line">      println(&quot;最后要被执行的代码&quot;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>scala中没有checked异常，都是在运行进行捕捉的</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def test4():Unit=&#123;</span><br><span class="line">    throw new ArithmeticException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三-方法的定义"><a href="#三-方法的定义" class="headerlink" title="三.方法的定义"></a>三.方法的定义</h2><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def methodName(arg1:type,arg2:type2)[:type]=&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项:</p><ul><li>当函数的返回值是unit是，＝可以省略</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> def test1(str:String):Unit=&#123;</span><br><span class="line"></span><br><span class="line">    println(str)</span><br><span class="line">&#125;</span><br><span class="line"> def test1(str:String)&#123;</span><br><span class="line"></span><br><span class="line">    println(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>返回值类型可以自动推断</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// return可以省略</span><br><span class="line">def add(a:Int,b:Int):Int=&#123;</span><br><span class="line">    a+b;</span><br><span class="line">&#125;</span><br><span class="line">// 返回值类型可以省略　=不可以省略，否则返回类型为Unit</span><br><span class="line">def add(a:Int,b:Int)=&#123;</span><br><span class="line"></span><br><span class="line">    a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>递归一定要声明返回值类型</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def fac(n:Int):Int=&#123;</span><br><span class="line"></span><br><span class="line">    if(n == 1)&#123;</span><br><span class="line">     return 1</span><br><span class="line">    &#125;</span><br><span class="line">    if (n==2)&#123;</span><br><span class="line">      return 2</span><br><span class="line">    &#125;</span><br><span class="line">    return fac(n-1)+fac(n-2)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>可以指定默认值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//如果指定实参会将默认值覆盖</span><br><span class="line">def test2(str:String=&quot;test2&quot;)=&#123;</span><br><span class="line">    println(str)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>可变参数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def test3(str:String,str2:Any*)=&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>返回值为Unit,忽略=</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def test1(str:String)&#123;</span><br><span class="line"></span><br><span class="line">   println(str)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="惰性函数"><a href="#惰性函数" class="headerlink" title="惰性函数"></a>惰性函数</h3><p>当函数的返回值被声明为lazy时，函数的执行将延迟，直到正在去取值的时候，函数才会执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lazy val lazyVal = add(10,20);</span><br><span class="line"></span><br><span class="line">def add(a:Int,b:Int)=&#123;</span><br><span class="line"></span><br><span class="line">    a+b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意:不能修饰var变量</p><p>​    lazy还可以用来修饰变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lazy val i = 1 //变量值的分配将会延迟</span><br></pre></td></tr></table></figure><h2 id="四-面向对象编程"><a href="#四-面向对象编程" class="headerlink" title="四.面向对象编程"></a>四.面向对象编程</h2><h3 id="1-类与对象"><a href="#1-类与对象" class="headerlink" title="1.类与对象"></a>1.类与对象</h3><ul><li>类的定义</li></ul><p>编写一个类，用scalac将器编译，再通过　javap -p 反编译查看生成的java代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//scala 类</span><br><span class="line">class Cat &#123;</span><br><span class="line"></span><br><span class="line">  var name:String = _</span><br><span class="line"></span><br><span class="line">  var age:Int = _</span><br><span class="line"></span><br><span class="line">  var gender:String = _</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>javap -p Cat.class</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class com.hsj.scala.day1.day2.Cat &#123;</span><br><span class="line">　//属性</span><br><span class="line">  private java.lang.String name;</span><br><span class="line">  private int age;</span><br><span class="line">  private java.lang.String gender;</span><br><span class="line">  //get set方法</span><br><span class="line">  public java.lang.String name();　//name的get</span><br><span class="line">  public void name_$eq(java.lang.String);//name的set</span><br><span class="line">  public int age(); //age get</span><br><span class="line">  public void age_$eq(int);//age set</span><br><span class="line">  public java.lang.String gender();//gender get</span><br><span class="line">  public void gender_$eq(java.lang.String);gendet set</span><br><span class="line">  //构造器</span><br><span class="line">  public com.hsj.scala.day1.day2.Cat();//默认构造器</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到　属性默认是private,如果使用的是var，对应的会生成get set 方法</p><p>如果使用val,则只会生成get方法</p><ul><li>创建对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def main(args: Array[String]): Unit = &#123;</span><br><span class="line">     val cat:Cat = new Cat</span><br><span class="line">     var cat2:Cat = new Cat</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>推荐使用val,因为创建对象一般不会改变它的引用，只是改变它的属性值</p><h3 id="2-构造器"><a href="#2-构造器" class="headerlink" title="2.构造器"></a>2.构造器</h3><p>scala的构造器与java的构造器有很多相同的地方，scala中的构造器可以定义多个，支持重载，这一点和java一样，但是scala也有自己的一些新特性，scala的构造器分为主构造器，辅助构造器，主构造器在类上声明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Cat(nameIn:String, ageIn:Int, gen:String)&#123; //主构造器</span><br><span class="line"></span><br><span class="line">  var name:String = _</span><br><span class="line"></span><br><span class="line">  var age:Int = _</span><br><span class="line"></span><br><span class="line">  var gender:String = _</span><br><span class="line"></span><br><span class="line">  def this()&#123;　//辅助构造器</span><br><span class="line">    this(&quot;jack&quot;,18,&quot;male&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><p>​    在辅助构造器中一定要在第一行调用主构造器</p><h4 id="主构造器中的参数"><a href="#主构造器中的参数" class="headerlink" title="主构造器中的参数"></a>主构造器中的参数</h4><ul><li>如果主构造器中的参数没有加修饰符修饰，默认为局部变量</li><li>主构造器中的参数使用var修饰，这个参数会升级成为成员变量，并且提供get set方法</li><li>主构造器中的参数使用val修饰，这个参数会升级成为成员变量，只提供get 方法</li></ul><h4 id="get-set方法"><a href="#get-set方法" class="headerlink" title="get set方法"></a>get set方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//get</span><br><span class="line">   val cat:Cat = new Cat</span><br><span class="line">    println(cat.name)</span><br><span class="line">    println(cat.age)</span><br><span class="line">    println(cat.gender)</span><br><span class="line">//set</span><br><span class="line">cat.name = &quot;mary&quot;</span><br><span class="line">    println(cat.name)</span><br></pre></td></tr></table></figure><p>如果想要使用java风格的get set需要在属性字段上添加@BeanProperty</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@BeanProperty var name:String = _</span><br><span class="line"></span><br><span class="line">println(cat.getName)</span><br></pre></td></tr></table></figure><h4 id="对象的创建流程"><a href="#对象的创建流程" class="headerlink" title="对象的创建流程"></a>对象的创建流程</h4><ol><li>new 关键字创建对象</li><li>识别new后面的类是否被加载，如果没有被加载，先加载类</li><li>在内存为该对象分配空间</li><li>调用父类构造器进行初始化</li><li>调用构造器进行初始化</li><li>将该对象的地址赋值给一个变量</li></ol><h3 id="3-package"><a href="#3-package" class="headerlink" title="3.package"></a>3.package</h3><p>scala中的包与java中的包作用一样</p><ol><li>区分相同名字的类</li><li>控制访问范围</li><li>类很多时，方便管理类</li></ol><p>scala默认导入三个包，java.lang ,scala._ ,scala.predef</p><h4 id="包的使用"><a href="#包的使用" class="headerlink" title="包的使用"></a>包的使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.hsj.packageTest</span><br><span class="line">package test&#123;   </span><br><span class="line">  class Test &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  package scala&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项：</p><p>package test{} :表示创建了包com.hsj.packageTest.test</p><p>在scala中，可以在一个文件中创建多个package,并且可以在包中创建类，特质，和对象</p><p>scala中子包可以访问父包中的内容，｛　｝体现了作用范围，当子包拥有与父包相同的类时，采用就近原则，如果希望指定哪个类，带上包名即可</p><p>如果想要在父包中使用子包的一些内容，需要在父包中import</p><p>包中不能定义变量和方法</p><h4 id="包对象"><a href="#包对象" class="headerlink" title="包对象"></a>包对象</h4><p>由于包中不能定义变量和方法，使用包对象补足</p><p>每一个包都可以拥有一个包对象，名字必须相同，在包对象中定义的变量和方法可以在包中使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package object scala&#123;</span><br><span class="line"></span><br><span class="line">  var name:String =&quot;scala&quot;;</span><br><span class="line"></span><br><span class="line">  def print():Unit=&#123;</span><br><span class="line">    println(name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">package scala&#123;</span><br><span class="line"></span><br><span class="line">  object test&#123;</span><br><span class="line">    def main(args: Array[String]): Unit = &#123;</span><br><span class="line">      print()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="scala中包的访问权限"><a href="#scala中包的访问权限" class="headerlink" title="scala中包的访问权限"></a>scala中包的访问权限</h4><ul><li>属性的访问权限为默认时，属性使用的是private修饰</li><li>方法的访问权限为默认时，属性使用的是public修饰</li><li>private只有在类的内部和伴生对象中可用</li><li>protected 只有在子类可以访问，同包无法访问，这点和java不同</li><li>scala添加了包访问权限，表示属于那个包</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package scala&#123;</span><br><span class="line"></span><br><span class="line">  object test&#123;</span><br><span class="line">    def main(args: Array[String]): Unit = &#123;</span><br><span class="line">      var per:Persion = new Persion</span><br><span class="line">      println(per.name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  class Persion&#123;</span><br><span class="line">    private [scala] var name:String = &quot;jack&quot; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-伴生类与伴生对象"><a href="#4-伴生类与伴生对象" class="headerlink" title="4.伴生类与伴生对象"></a>4.伴生类与伴生对象</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>在scala中，类用class表示，object表示的一个静态的对象，如果class的名称与object的名称相同，该类被称为半生类，object被称为伴生对象。伴生对象的内容都是静态的，可以通过类名直接调用，类和其伴生对象可以互相访问私有属性，但必须存在同一个源文件中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">object User&#123;</span><br><span class="line">  var name:String = &quot;jack&quot;</span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line"></span><br><span class="line">    println(User.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class User(  var name:String)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="apply方法"><a href="#apply方法" class="headerlink" title="apply方法"></a>apply方法</h4><p>使用apply(装配器，将属性装配到对象)方法，实现类名(参数)的方式创建对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">object User&#123;</span><br><span class="line"></span><br><span class="line">  def apply():User=new User();</span><br><span class="line"></span><br><span class="line">  def apply(name:String): User = new User(name)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class User()&#123;</span><br><span class="line">  var name:String = _;</span><br><span class="line">  def this(name:String)&#123;</span><br><span class="line">    this</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">object test&#123;</span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val u1 = User(&quot;link&quot;)</span><br><span class="line">    println(u1.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-trait-特质"><a href="#5-trait-特质" class="headerlink" title="5.trait(特质)"></a>5.trait(特质)</h3><h4 id="特质的声明"><a href="#特质的声明" class="headerlink" title="特质的声明"></a>特质的声明</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">trait 特质名&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="特质的使用"><a href="#特质的使用" class="headerlink" title="特质的使用"></a>特质的使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class 类名　extends 父类 with trait1 with trait2 with trait3...</span><br></pre></td></tr></table></figure><p>特质中可以拥有抽象方法和具体方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">trait Persion &#123;</span><br><span class="line"></span><br><span class="line">  def eat()</span><br><span class="line"></span><br><span class="line">  def sleep(): Unit =&#123;</span><br><span class="line">    println(&quot;sleep~~~~&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="动态混入"><a href="#动态混入" class="headerlink" title="动态混入"></a>动态混入</h4><p>除了可以在类声明的时候继承特质，还可以在构建对象是动态的混入特质，达到扩展功能的效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">trait Persion &#123;</span><br><span class="line"></span><br><span class="line">  def eat()</span><br><span class="line"></span><br><span class="line">  def sleep(): Unit =&#123;</span><br><span class="line">    println(&quot;sleep~~~~&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">trait Animal&#123;</span><br><span class="line">  def fright(): Unit =&#123;</span><br><span class="line">    println(&quot;fright~~~&quot;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def run();</span><br><span class="line">&#125;</span><br><span class="line">class P1 extends Persion&#123;</span><br><span class="line">  override def eat(): Unit = &#123;</span><br><span class="line">    println(&quot;eat~~~~~&quot;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">object P1&#123;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val p1 = new P1 with Animal&#123;</span><br><span class="line">      override def run(): Unit = &#123;</span><br><span class="line">        </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p1.eat()</span><br><span class="line">    p1.fright()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>叠加特质:构建对象时混入多个特质，称为叠加特质</p><p>叠加特质的声明是从左到右，方法的执行是从右到左</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">object TestTrait &#123;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">//声明从左到右，执行从右到左　类似栈</span><br><span class="line">    val abc = new ABC with A1 with A2</span><br><span class="line"></span><br><span class="line">    abc.test　//执行的是A2中的test方法</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class ABC&#123;</span><br><span class="line">&#125;</span><br><span class="line">trait Total&#123;</span><br><span class="line">  def test;</span><br><span class="line">&#125;</span><br><span class="line">trait A extends Total &#123;</span><br><span class="line"> override def test: Unit =&#123;</span><br><span class="line">      println(&quot;A test~~&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  println(&quot;A~~&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trait A1 extends A&#123;</span><br><span class="line">  override def test: Unit =&#123;</span><br><span class="line">    println(&quot;A1 test~~&quot;)</span><br><span class="line">    super.test</span><br><span class="line">  &#125;</span><br><span class="line">  println(&quot;A1~~&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trait A2 extends A&#123;</span><br><span class="line">  override def test: Unit =&#123;</span><br><span class="line">    println(&quot;A2 test~~&quot;)</span><br><span class="line">    super.test　　</span><br><span class="line">  &#125;</span><br><span class="line">  println(&quot;A2~~&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>叠加特质一定要注意方法的执行顺序如上述代码中，先执行A2中的test，执行到 super.test的时候，执行的不一定是父特质的方法，它会根据混入的特质的顺序执行<strong>，执行的是它左边的特质中的test方法</strong>，<strong>如果左边没有特质则执行父特质的方法。</strong></p><p>上述代码执行顺序：</p><p>A2.test–&gt;A1.test–&gt;A.test</p><p>注意:A1和A2继承的是同一个父特质，如果不是同一个父特质，那么A2中的super执行的是父特质test</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">object TestTrait &#123;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val abc = new ABC with A1 with A2</span><br><span class="line">    abc.test</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class ABC&#123;</span><br><span class="line">&#125;</span><br><span class="line">trait Total&#123;</span><br><span class="line">  def test;</span><br><span class="line">&#125;</span><br><span class="line">trait A extends Total &#123;</span><br><span class="line"> override def test: Unit =&#123;</span><br><span class="line">      println(&quot;A test~~&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  println(&quot;A~~&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trait B extends Total&#123;</span><br><span class="line">  override def test: Unit =&#123;</span><br><span class="line">    println(&quot;B test~~&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  println(&quot;B~~&quot;)</span><br><span class="line">&#125;</span><br><span class="line">trait A1 extends A&#123;</span><br><span class="line">  override def test: Unit =&#123;</span><br><span class="line">    println(&quot;A1 test~~&quot;)</span><br><span class="line">    super.test</span><br><span class="line">  &#125;</span><br><span class="line">  println(&quot;A1~~&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trait A2 extends B&#123;</span><br><span class="line">  override def test: Unit =&#123;</span><br><span class="line">    println(&quot;A2 test~~&quot;)</span><br><span class="line">    super.test</span><br><span class="line">  &#125;</span><br><span class="line">  println(&quot;A2~~&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行顺序:A2.test—&gt;B.test</p><h4 id="富接口"><a href="#富接口" class="headerlink" title="富接口"></a>富接口</h4><p>富接口：该特质中既有抽象方法又有非抽象方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">trait Persion &#123;</span><br><span class="line">  def eat()</span><br><span class="line">  def sleep(): Unit =&#123;</span><br><span class="line">    println(&quot;sleep~~~~&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="trait中的字段"><a href="#trait中的字段" class="headerlink" title="trait中的字段"></a>trait中的字段</h4><p>trait中可以定义具体的字段和抽象的字段，一个对象如果混入该特质，就拥有了特质中的字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">object TestTrait2 extends App &#123;</span><br><span class="line">   val param =  new T with Param&#123;</span><br><span class="line">      override val age: Int = 18</span><br><span class="line">    &#125;</span><br><span class="line">  println(param.name)</span><br><span class="line">&#125;</span><br><span class="line">trait Param&#123;</span><br><span class="line">    val name:String = &quot;jack&quot;</span><br><span class="line">    val age:Int;</span><br><span class="line">&#125;</span><br><span class="line">class T&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="trait的构造顺序"><a href="#trait的构造顺序" class="headerlink" title="trait的构造顺序"></a>trait的构造顺序</h4><p>创建对象时混入特质</p><ol><li>调用当前类的超类的构造器</li><li>调用第一个trait的的超类构造器</li><li>调用第一个trait的构造器</li><li>调用第二个trait的超类构造器</li><li>调用第二个trait的构造器</li><li>调用当前类的构造</li></ol><h4 id="trait的扩展类"><a href="#trait的扩展类" class="headerlink" title="trait的扩展类"></a>trait的扩展类</h4><p>trait可以继承类，如果有那个类(A)混入了该trait,那么，这个类（A)会成为trait的超类的子类，</p><p>如果这个类（Ａ）还继承了别的类，继承的这个类一定要是trait的超类的子类，否则会发生多继承的错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">object TestTrait3 &#123;</span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">     val a =  new A</span><br><span class="line">    println(a.getMessage)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">trait TraitException extends Exception&#123;</span><br><span class="line">  override def getMessage: String = &#123;</span><br><span class="line">    return &quot;TraitException&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class A extends Exception with TraitException&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决该情况在idea中编译时不报错的方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 自身类型</span><br><span class="line">trait TraitException extends Exception&#123;</span><br><span class="line">this:Exception =&gt;</span><br><span class="line">  override def getMessage: String = &#123;</span><br><span class="line">    return &quot;TraitException&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-重写"><a href="#6-重写" class="headerlink" title="6.重写"></a>6.重写</h3><ol><li>在Scala中重写一个非抽象方法必须使用override修饰符。 </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class week extends month&#123; override def firstday = &#123;...&#125; &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>.重写包括字段和方法，但参数不同的方法可以不重写 </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class month&#123; </span><br><span class="line">def secondday（m:String）=&#123;...&#125;</span><br><span class="line">&#125; </span><br><span class="line">class week extends month&#123; </span><br><span class="line">def secondday =&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>在Scala中调用超类的方法和Java一样，使用super关键字</li><li>只有主构造器可以调用超类的主构造器;</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Employee(name:String,age:Int,val salary:Double) extends Person(name:String,age:Int)</span><br></pre></td></tr></table></figure><ol start="5"><li>重写规则</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">重写 def </span><br><span class="line">    用val ：利用val能重写超类用没有参数的方法(getter) </span><br><span class="line">    用def：子类的方法与超类方法重名 </span><br><span class="line">重写val </span><br><span class="line">    用val：子类的一个私有字段与超类的字段重名，getter方法重写超类的getter方法 </span><br><span class="line">重写var </span><br><span class="line">用var：且当超类的var是抽象的才能被重写，否则超类的var都会被继承</span><br></pre></td></tr></table></figure><h3 id="7-嵌套类"><a href="#7-嵌套类" class="headerlink" title="7.嵌套类"></a>7.嵌套类</h3><h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class OuterClass &#123;</span><br><span class="line">  //别名</span><br><span class="line">  outerClass =&gt;</span><br><span class="line">  var name:String = &quot;jack&quot;</span><br><span class="line">  class InnerClass&#123;</span><br><span class="line">    def inner: Unit =&#123;</span><br><span class="line"></span><br><span class="line">      //访问外部类的属性 1</span><br><span class="line">      println(OuterClass.this.name)</span><br><span class="line"></span><br><span class="line">      //访问外部类的属性 2 别名</span><br><span class="line">      println(outerClass.name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  def tets: Unit =&#123;</span><br><span class="line">    //创建内部类的对象</span><br><span class="line">  　val outerClass =  new OuterClass</span><br><span class="line">    val innerClass:outerClass.InnerClass = new outerClass.InnerClass</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class OuterClass &#123;</span><br><span class="line">  def tets: Unit =&#123;</span><br><span class="line">    //创建静态内部类对象</span><br><span class="line">    val staticInnerClass = new OuterClass.StaticInnerClass</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//伴生对象</span><br><span class="line">object OuterClass&#123;</span><br><span class="line">  class StaticInnerClass&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类型投影"><a href="#类型投影" class="headerlink" title="类型投影"></a>类型投影</h4><p>创建内部类时，创建的内部类会与外部类实例产生关联</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class OuterClass2 &#123;</span><br><span class="line"></span><br><span class="line">  class InnerClass&#123;</span><br><span class="line"></span><br><span class="line">    def test(innerClass: InnerClass): Unit =&#123;</span><br><span class="line">        println(innerClass)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">object OuterClassDemo&#123;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line"></span><br><span class="line">    val outer1 = new OuterClass2</span><br><span class="line">    val outer2 = new OuterClass2</span><br><span class="line">    val inner1 = new outer1.InnerClass</span><br><span class="line">    val inner2 = new outer2.InnerClass</span><br><span class="line">    inner1.test(inner1);</span><br><span class="line">    inner2.test(inner2)</span><br><span class="line">//报错　由于inner1已经和外部类实例outer1关联，inner1调用test方法传入的参数只能是outer1.InnerClass</span><br><span class="line">//    inner1.test(inner2) </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了解决上述问题，只需要在方法声明上添加 外部类#内部类,表示忽略外部类实例与内部类实例的关系</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def test(innerClass: OuterClass2#InnerClass): Unit =&#123;</span><br><span class="line">      println(innerClass)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##　五.隐式转换和隐式值</p><h4 id="1-隐式转换解决数据类型的转换"><a href="#1-隐式转换解决数据类型的转换" class="headerlink" title="1.隐式转换解决数据类型的转换"></a>1.隐式转换解决数据类型的转换</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">object ImpliciteTest&#123;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line"></span><br><span class="line">//在底层生成f1$1(double d)的方法，将double强转为int</span><br><span class="line">    implicit def f1(d:Double):Int=&#123;</span><br><span class="line">      d.toInt</span><br><span class="line">    &#125;</span><br><span class="line">//底层调用f1$1（2.5)的方法</span><br><span class="line">    val i = 2.5;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-隐式值"><a href="#2-隐式值" class="headerlink" title="2.隐式值"></a>2.隐式值</h4><p>隐式值也叫隐式变量，当一个方法在省略隐式参数时，会自动搜索作用域的隐式参数作为缺省参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> def main(args: Array[String]): Unit = &#123;</span><br><span class="line"></span><br><span class="line">    implicit val name:String = &quot;lix&quot;</span><br><span class="line"></span><br><span class="line">    def test(implicit name:String): Unit =&#123;</span><br><span class="line">      println(name)</span><br><span class="line">    &#125;</span><br><span class="line">    test</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-隐式值，默认值，传值的优先级"><a href="#3-隐式值，默认值，传值的优先级" class="headerlink" title="3.隐式值，默认值，传值的优先级"></a>3.隐式值，默认值，传值的优先级</h4><p>传值&gt;隐式值&gt;默认值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> def main(args: Array[String]): Unit = &#123;</span><br><span class="line"></span><br><span class="line">   implicit val name:String = &quot;lix&quot;</span><br><span class="line"></span><br><span class="line">   def test(implicit  name:String=&quot;jack&quot;): Unit =&#123;</span><br><span class="line">     println(name)</span><br><span class="line">   &#125;</span><br><span class="line">   test　//结果为lix</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line"></span><br><span class="line">   implicit val name:String = &quot;lix&quot;</span><br><span class="line"></span><br><span class="line">   def test(implicit  name:String=&quot;jack&quot;): Unit =&#123;</span><br><span class="line">     println(name)</span><br><span class="line">   &#125;</span><br><span class="line">   test(&quot;xxx&quot;)　//结果为xxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-隐式类"><a href="#4-隐式类" class="headerlink" title="4.隐式类"></a>4.隐式类</h4><p>隐式类必须定义在类，伴生对象，包对象中，不能作为一个顶级类存在，并且隐式类有且只有一个构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">object ImpliciteTest&#123;</span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">  // implicit 修饰的是构造器</span><br><span class="line">    implicit class A(b: B)&#123;</span><br><span class="line">      def test: Unit =&#123;</span><br><span class="line">        println(&quot;隐式类的调用&quot;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    val b = new B</span><br><span class="line">    b.test</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class B&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>隐式类的转换时机</p><ol><li>方法中的参数与它需要的参数类型不一致，或者是在赋值的时候</li><li>当一个对象调用本类不存在的方法或参数时</li></ol><h2 id="六-数据结构"><a href="#六-数据结构" class="headerlink" title="六.数据结构"></a>六.数据结构</h2><h3 id="1-集合关系"><a href="#1-集合关系" class="headerlink" title="1.集合关系"></a>1.集合关系</h3><p>scala集合包括可变集合和不可变集合,scala集合有三大类.序列seq,集合set，映射map</p><p>可变集合：scala.collection.mutable,集合本身不能动态改变，java中的数组</p><p>不可变集合：scala.collection.immutable，集合本身可以动态改变，java中的ArrayList</p><p>不可变集合预览图</p><p><img src="https://handerh-1259550163.cos.ap-shanghai.myqcloud.com/java/scala/scala3.png" alt></p><p>可变集合预览图</p><p><img src="https://handerh-1259550163.cos.ap-shanghai.myqcloud.com/java/scala/scala4.png" alt></p><h3 id="2-数组"><a href="#2-数组" class="headerlink" title="2.数组"></a>2.数组</h3><h4 id="不可变数组"><a href="#不可变数组" class="headerlink" title="不可变数组"></a>不可变数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//　定义方式一</span><br><span class="line"> val a1 = new Array[String](5)</span><br><span class="line"> //　定义方式二</span><br><span class="line"> val a2 = Array(&quot;hello&quot;,&quot;scala&quot;)</span><br><span class="line"></span><br><span class="line"> //遍历方式一</span><br><span class="line"> for (elem &lt;- a2) &#123;</span><br><span class="line">   println(elem)</span><br><span class="line"> &#125;</span><br><span class="line"> //遍历方式二</span><br><span class="line"> for (i&lt;-0 to a2.length)&#123;</span><br><span class="line">   println(a2(i))</span><br><span class="line"> &#125;</span><br><span class="line"> //遍历方式三</span><br><span class="line"> a2.foreach(println)</span><br></pre></td></tr></table></figure><h4 id="可变数组"><a href="#可变数组" class="headerlink" title="可变数组"></a>可变数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">val ab1 = ArrayBuffer[String](&quot;hello&quot;,&quot;scala&quot;)</span><br><span class="line"> val ab2 = ArrayBuffer[String](&quot;hello2&quot;,&quot;scala2&quot;)</span><br><span class="line"></span><br><span class="line"> //append 在原数组后面追加数据</span><br><span class="line">   ab1.append(&quot;ab1&quot;,&quot;append&quot;)</span><br><span class="line">   </span><br><span class="line"> //remove 删除数组指定下标的元素并将其返回</span><br><span class="line">   val res1: String = ab1.remove(0)</span><br><span class="line">   </span><br><span class="line"> //从数组下标为0的位置开始，删除两个元素</span><br><span class="line">   val res2 = ab1.remove(0,2);</span><br><span class="line">   </span><br><span class="line"> 　//drop 删除指定个数的元素　返回删除的元素，形成一个新的数组　原数组不变</span><br><span class="line">   val res3:ArrayBuffer[String] = ab1.drop(2)</span><br><span class="line">   </span><br><span class="line">   /dropRight 从右边删除指定个数的元素　返回删除的元素，形成一个新的数组</span><br><span class="line">    val ab2 = ab.dropRight(3)</span><br><span class="line">    //可变数组转化为不可变数组　原数组不发生改变</span><br><span class="line">   val newArr: Array[String] = ab1.toArray</span><br><span class="line">   </span><br><span class="line">    //将不可变数组转化为可变数组，原数组不发生改变</span><br><span class="line">   val newBuf = newArr.toBuffer</span><br><span class="line">   </span><br><span class="line">    //在ab1后面追加集合ab2</span><br><span class="line">   ab1 ++= ab2;</span><br><span class="line">   </span><br><span class="line">   //在ab1前面追加集合ab2</span><br><span class="line">   ab1.++=:(ab2)  // ab2 ++=: ab1</span><br><span class="line">     </span><br><span class="line">   //在集合ab1后面追加集合ab2并返回一个新的集合</span><br><span class="line">   val ab3 = ab1.++(ab2)</span><br><span class="line">   </span><br><span class="line">   //在集合ab1前面追加集合ab2并返回一个新的集合</span><br><span class="line">    val ab4 = ab1.++:(ab2)</span><br><span class="line">   </span><br><span class="line">   ab1.+=(&quot;hello+=&quot;)</span><br><span class="line">   ab1.+=:(&quot;hello+=:&quot;)</span><br><span class="line">   val ab5 = ab1.+(&quot;hello+&quot;);</span><br><span class="line">   val ab6 = ab1.+(&quot;hello+:&quot;)</span><br></pre></td></tr></table></figure><h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> val arr: Array[Array[String]] = Array.ofDim[String](5,4)</span><br><span class="line"></span><br><span class="line">    for (item&lt;-arr)&#123;</span><br><span class="line">      for (res&lt;-item)&#123;</span><br><span class="line">        print(res+&quot;\t&quot;)</span><br><span class="line">      &#125;</span><br><span class="line">    println</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-元组"><a href="#3-元组" class="headerlink" title="3.元组"></a>3.元组</h3><p>元组可以存放各种数据类型不同的数据，元组将多个无关的数据封装成为一个整体，元组最多只能有22个元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 元组的定义</span><br><span class="line">     val t1: Tuple1[String] = new Tuple1(&quot;1&quot;)</span><br><span class="line">     val t3: (Int, Int, String) = new Tuple3(1,2,&quot;str&quot;)</span><br><span class="line">     val t4 = (&quot;1&quot;,2.1,&quot;str&quot;,&quot;hello&quot;)</span><br><span class="line"></span><br><span class="line">     //元组的访问</span><br><span class="line">     println(t4._1)</span><br><span class="line">     println(t4._2)</span><br><span class="line">     //元组的遍历</span><br><span class="line">     for (i&lt;-t3.productIterator)&#123;</span><br><span class="line">       println(i)</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h3 id="4-List"><a href="#4-List" class="headerlink" title="4.List"></a>4.List</h3><p>当我们定义一个List时在scala中是不可变的，如果需要使用可变的，需要使用ListBuffer</p><h4 id="不可变集合List"><a href="#不可变集合List" class="headerlink" title="不可变集合List"></a>不可变集合List</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//不可变集合</span><br><span class="line">  val l1 = List(1,2,&quot;abc&quot;)</span><br><span class="line">  </span><br><span class="line">   val list = List(1,2,3,&quot;str&quot;)</span><br><span class="line">  // ::　集合对象一定要放在右边　如果不加Nil会形成一个集合，如果加Nil,会形多个集合的集合</span><br><span class="line">  val list2 = 4::5::list //List(4, 5, 1, 2, 3, str)</span><br><span class="line">  val list3 = 4::5::list::Nil //List(4, 5, List(1, 2, 3, str))</span><br><span class="line">  //::: 将集合中的每一个元素添加到集合中去 注意 ::: 左右两边都要是集合</span><br><span class="line">  val list4 = 4::5::immutable.Nil:::list</span><br><span class="line">  println(list4)</span><br></pre></td></tr></table></figure><h4 id="可变集合ListBuffer"><a href="#可变集合ListBuffer" class="headerlink" title="可变集合ListBuffer"></a>可变集合ListBuffer</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//可变集合</span><br><span class="line">   val lb = ListBuffer(11,22,&quot;abc2&quot;)</span><br><span class="line">   println(lb.length)</span><br><span class="line"></span><br><span class="line">   //;list元素的访问</span><br><span class="line">   println(lb(1))</span><br><span class="line"></span><br><span class="line">   //遍历</span><br><span class="line">   for (i&lt;-lb)&#123;</span><br><span class="line">     println(i)</span><br><span class="line">   &#125;</span><br><span class="line">   // 获取除第一个元素外的其它元素</span><br><span class="line">   val tail =   lb.tail</span><br><span class="line">   println(tail)</span><br><span class="line"></span><br><span class="line">   // 从右边开始获取n个元素</span><br><span class="line">  val tr =  lb.takeRight(2)</span><br><span class="line">   println(tr)</span><br><span class="line">   </span><br><span class="line">   // 获取n个元素</span><br><span class="line">  val t = lb.take(2)</span><br><span class="line">   println(t)</span><br><span class="line">   //获取符合条件的元素</span><br><span class="line">   val tw = lb.takeWhile(i=&gt;i==null)</span><br><span class="line">   println(tw)</span><br><span class="line">   println(lb)</span><br><span class="line"></span><br><span class="line">   println(&quot;===========================&quot;)</span><br><span class="line"></span><br><span class="line">   //删除n个元素,将删除后的原集合剩下的元素返回</span><br><span class="line">   val ld = lb.drop(2)</span><br><span class="line">   println(ld)</span><br><span class="line">   //从右边开始删除n个元素,将删除后的原集合剩下的元素返回</span><br><span class="line">   val dr = lb.dropRight(2)</span><br><span class="line">   println(dr)</span><br><span class="line"></span><br><span class="line">   //删除满足条件的元素，将删除后的原集合剩下的元素返回</span><br><span class="line">   val dw = lb.dropWhile(elem =&gt; elem!=null)</span><br><span class="line">   println(dw)</span><br></pre></td></tr></table></figure><h4 id="映射Map"><a href="#映射Map" class="headerlink" title="映射Map"></a>映射Map</h4><p>scala中的集合默认是不可变的，如果需要使用可变的，可以使用scala.collection.mutabl下的类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//定义</span><br><span class="line">    val map1 = Map((1,&quot;li&quot;),(2,&quot;xi&quot;),(3,&quot;jiafeng&quot;))</span><br><span class="line">    map1.+((4,&quot;meng&quot;))</span><br><span class="line">    val map2 = mutable.Map((1,&quot;lo2&quot;),(2,&quot;xo2&quot;))</span><br><span class="line">//取值</span><br><span class="line">    // map1(4) 如果不存在　NoSuchElementException</span><br><span class="line">    // 如果存在　返回Some 不存在返回None</span><br><span class="line">    println(map1.get(3))</span><br><span class="line">   //　如果值存在　返回值　不存在　返回　默认值</span><br><span class="line">    println(map1.getOrElse(4,&quot;NULL&quot;))</span><br><span class="line"></span><br><span class="line">//添加｜修改　如果不存在则添加，存在则覆盖</span><br><span class="line">    map2(1) = &quot;lolo&quot;</span><br><span class="line">    println(map2)</span><br><span class="line">    map2.+=((1,&quot;xxx&quot;));</span><br><span class="line">    println(map2)</span><br><span class="line">    </span><br><span class="line"> //遍历方式</span><br><span class="line">    for ((k,v)&lt;- map2)&#123;</span><br><span class="line">      println(k+&quot; &quot;+v)</span><br><span class="line">    &#125;</span><br><span class="line">    for (m&lt;- map2)&#123;</span><br><span class="line">      println(m._1+&quot; &quot;+m._2)</span><br><span class="line">    &#125;</span><br><span class="line">    for (k &lt;- map2.keys)&#123;</span><br><span class="line">      println(k+&quot; &quot;+map2(k))</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>不重复元素的集合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//定义</span><br><span class="line">    //不可变集合</span><br><span class="line">    val set1 = Set(6,1,2,3,1)</span><br><span class="line">    //不可变集合</span><br><span class="line">    val set2 = mutable.Set(6,1,2,3,1)</span><br><span class="line">    println(set1)</span><br><span class="line"></span><br><span class="line">//增</span><br><span class="line">    set2.+=(4)</span><br><span class="line">    set2.add(5)</span><br><span class="line">//删</span><br><span class="line">    set2.-=(4)</span><br><span class="line">    set2.remove(5)</span><br><span class="line">    println(set2)</span><br><span class="line">//遍历</span><br><span class="line">    for (i&lt;- set2)&#123;</span><br><span class="line">      println(i)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="集合元素的操作"><a href="#集合元素的操作" class="headerlink" title="集合元素的操作"></a>集合元素的操作</h4><ol><li>将List(1,2,3)中的所有元素*2</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val list =  List(1,2,3,4,5)</span><br><span class="line">val res1 = list.map(i =&gt; i*2)</span><br><span class="line">println(res1)</span><br></pre></td></tr></table></figure><ol start="2"><li>将List(“hello”,”world”,”scala”)中的所有单词，全部转为大写</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val res2 = list2.map(word=&gt;word.toUpperCase)</span><br><span class="line">    println(res2)</span><br></pre></td></tr></table></figure><ol start="3"><li>flatMap 扁平化</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val res3 =  list2.flatMap(s=&gt;s.toUpperCase)</span><br><span class="line">println(res3) // List(H, E, L, L, O, W, O, R, L, D, S, C, A, L, A)</span><br><span class="line"></span><br><span class="line">val list3 = List(List(1,2,3),List(4,5,6),List(7,8,9))</span><br><span class="line">println(list3.flatMap(i =&gt; i.map(j=&gt;j*2)))//List(2, 4, 6, 8, 10, 12, 14, 16, 18)</span><br></pre></td></tr></table></figure><ol start="4"><li>filter 过滤</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val list =  List(1,2,3,4,5)</span><br><span class="line">val res =  list.filter(i =&gt; i%2==0)</span><br><span class="line">println(res)//List(2, 4)</span><br></pre></td></tr></table></figure><ol start="5"><li>reduce</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">val list =  List(1,2,3,4,5)</span><br><span class="line">val res = list.reduce((a,b)=&gt;a+b)</span><br><span class="line">println(res)</span><br><span class="line">// ((((1-2)-3)-4)-5) </span><br><span class="line">println(list.reduceLeft((a,b)=&gt;a-b))</span><br><span class="line">//(1-(2-(3-(4-5))))</span><br><span class="line">println(list.reduceRight((a,b)=&gt;a-b))</span><br></pre></td></tr></table></figure><ol start="6"><li>fold</li></ol><p>把上一步的返回值交给下一步，继续参与运算</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">val list =  List(1,2,3,4,5)</span><br><span class="line"> //类似　 List(1,1,2,3,4,5).reduceLeft((num1,num2)=&gt;num1-num2))</span><br><span class="line"> println(list.fold(1)((num1,num2)=&gt;num1-num2))</span><br><span class="line"> //类似List(1,1,2,3,4,5).reduceLeft((num1,num2)=&gt;num1-num2))</span><br><span class="line"> println(list.foldLeft(1)((num1,num2)=&gt;num1-num2))</span><br><span class="line"> //类似List(1,2,3,4,5,１).reduceLeft((num1,num2)=&gt;num1-num2))　</span><br><span class="line"> println(list.foldLeft(1)((num1,num2)=&gt;num1-num2))</span><br><span class="line"> </span><br><span class="line"> //foldLeft 的缩写为　/: foldRight 的缩写为　\:</span><br><span class="line"> println(list./:(1)((num1,num2)=&gt;num1-num2))</span><br><span class="line"> println(list.:\(1)((num1,num2)=&gt;num1-num2))</span><br></pre></td></tr></table></figure><ol start="7"><li>scan</li></ol><p>对集合中的所有元素做fold操作，但是会保留每步的操作结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">val list =  List(1,2,3,4,5)</span><br><span class="line">   val res: List[Int] = list.scan(5)((n1, n2)=&gt;n1-n2)</span><br><span class="line">   println(res)//List(5, 4, 2, -1, -5, -10)</span><br><span class="line">   val res2 = list.scanLeft(5)((n1, n2)=&gt;n1-n2)</span><br><span class="line">   println(res2)//List(5, 4, 2, -1, -5, -10)</span><br><span class="line">   val res3 = list.scanRight(5)((n1, n2)=&gt;n1-n2)</span><br><span class="line">   println(res3)//List(-2, 3, -1, 4, 0, 5)</span><br></pre></td></tr></table></figure><ol start="8"><li>拉链操作</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">val l1 =  List(1,2,3,4)</span><br><span class="line">val l2 = List(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;)</span><br><span class="line">println(l1.zip(l2)) // 会造成数据丢失List((1,a), (2,b), (3,c), (4,d))</span><br><span class="line">// 三个参数</span><br><span class="line">println(l1.zipAll(l2,&quot;l1N&quot;,&quot;l2N&quot;))//List((1,a), (2,b), (3,c), (4,d), (l1N,e))</span><br><span class="line"></span><br><span class="line">val res = l1.zipAll(l2,0,&quot;l2N&quot;)</span><br><span class="line">println(res)//List((1,a), (2,b), (3,c), (4,d), (0,e))</span><br><span class="line">val res2: (List[Int], List[String]) = res.unzip</span><br><span class="line">println(res2)// (List(1, 2, 3, 4, 0),List(a, b, c, d, e))</span><br></pre></td></tr></table></figure><ol start="9"><li>java集合与scala集合互相转换</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// java集合与scala集合的互相转换</span><br><span class="line">  import scala.collection.JavaConverters._</span><br><span class="line">  val scalaList = List(1,2,3,4,5,6)</span><br><span class="line">  val javaList: util.List[Int] = scalaList.asJava</span><br><span class="line">  val scalaList2 = javaList.asScala</span><br><span class="line">  val scalaMap = Map((1,&quot;a&quot;),(2,&quot;b&quot;))</span><br><span class="line">  val javaMap = scalaMap.asJava</span><br><span class="line">  val scalaMap2 = javaMap.asScala</span><br></pre></td></tr></table></figure><h2 id="七-模式匹配"><a href="#七-模式匹配" class="headerlink" title="七.模式匹配"></a>七.模式匹配</h2><h3 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1.基本介绍"></a>1.基本介绍</h3><p>采用match关键字声明，每个分支采用case关键字声明,需要匹配时从第一个case开始，如果匹配成功，执行相应的逻辑代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">val oper:Char = &apos;2&apos;</span><br><span class="line">  val n1:Int  = 10</span><br><span class="line">  val n2:Int  =20</span><br><span class="line">  </span><br><span class="line">  val res = oper match &#123;</span><br><span class="line">    case &apos;+&apos; =&gt; n1+n2</span><br><span class="line">    case &apos;-&apos; =&gt; n1-n2</span><br><span class="line">    case _ =&gt; println(&quot;error&quot;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>注意:</p><ol><li>如果所有的case都不匹配则执行case _ ,如果没有case _ 会抛出一个MatchException</li><li>如果case _后面有条件判断（守卫），则case _不是默认匹配</li><li>case后面跟变量，match前面的值会赋值给变量</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">oper match &#123;</span><br><span class="line">   case a =&gt;  if (a.equals(&apos;+&apos;)) n1+n2</span><br><span class="line">   case b =&gt;  if (b.equals(&apos;-&apos;)) n1-n2</span><br><span class="line">   case _ =&gt; println(&quot;error&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-类型匹配"><a href="#2-类型匹配" class="headerlink" title="2.类型匹配"></a>2.类型匹配</h3><p>在类型匹配时，编译器会自动判断有没有可能匹配的类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    //类型匹配</span><br><span class="line">    val a:Int = 1</span><br><span class="line">    a match &#123;</span><br><span class="line">      case t1:Int =&gt; &quot;Int&quot;</span><br><span class="line">//      case t2:String =&gt;&quot;String&quot;</span><br><span class="line">      case t3:Long =&gt; “long”</span><br><span class="line">//      case t4:List[Int] =&gt; &quot;list[Int]&quot;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="3-数组匹配"><a href="#3-数组匹配" class="headerlink" title="3.数组匹配"></a>3.数组匹配</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">val arrs = Array(Array(0,1),Array(0),Array(0,1,2,3))</span><br><span class="line"> for (arr&lt;-arrs)&#123;</span><br><span class="line">  val res =  arr match &#123;</span><br><span class="line">     case Array(x) =&gt; x</span><br><span class="line">     case Array(x,y) =&gt; ArrayBuffer(y,x)</span><br><span class="line">     case Array(0,_*) =&gt; &quot;以0开头&quot;</span><br><span class="line">     case _ =&gt; &quot;other&quot;</span><br><span class="line">   &#125;</span><br><span class="line">   println(res)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="4-列表匹配"><a href="#4-列表匹配" class="headerlink" title="4.列表匹配"></a>4.列表匹配</h3><p>拥有unapply方法的集合才能够进行匹配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">val lists = List(List(1),List(1,2),List(0,List(1,2)))</span><br><span class="line"></span><br><span class="line">    for (list&lt;-lists)&#123;</span><br><span class="line">     val res =  list match &#123;</span><br><span class="line">        case x::Nil =&gt; x</span><br><span class="line">        case 0::tail=&gt; &quot;...&quot;</span><br><span class="line">        case x::y::Nil =&gt; x+&quot;&quot;+y</span><br><span class="line">        case _ =&gt; &quot;some else &quot;</span><br><span class="line">      &#125;</span><br><span class="line">      println(res)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="5-对象匹配"><a href="#5-对象匹配" class="headerlink" title="5.对象匹配"></a>5.对象匹配</h3><p>对象匹配需要通过unapply方法进行匹配，unapply是一个对象提取器，返回some则表示匹配成功，返回None表示匹配失败。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">object Nums&#123;</span><br><span class="line"></span><br><span class="line">  def apply(x:Double): Double = &#123;</span><br><span class="line"></span><br><span class="line">    Math.pow(x,2)</span><br><span class="line">  &#125;</span><br><span class="line">  def unapply(arg: Double): Option[Double] =&#123;</span><br><span class="line">   Some(Math.sqrt(arg))</span><br><span class="line">//    None</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val nums = Nums(6)</span><br><span class="line">    nums match &#123;</span><br><span class="line">      // 调用unapply方法，将返回值赋值给n</span><br><span class="line">      case Nums(n) =&gt; println(n)</span><br><span class="line">      case _ =&gt; println(&quot;else&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-样例类"><a href="#6-样例类" class="headerlink" title="6.样例类"></a>6.样例类</h3><p>样例类使用case声明的一种特殊的类，构造器中的每个参数默都是val，它提供了apply方法用于创建对象，提供unapply方法用于进行模式匹配，此外，它还提供了equals ,copy,toString等方法。样例类对应了两个class文件，类名.class,类名$.class.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">object TestCaseClass &#123;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line"></span><br><span class="line">    for (i&lt;-(Array(Dollar(1000,&quot;$&quot;),Currency(1000,&quot;RMB&quot;))))&#123;</span><br><span class="line">      i match &#123;</span><br><span class="line">        case Dollar(x,y) =&gt; println(x+&quot; &quot;+y)</span><br><span class="line">        case Currency(x,y) =&gt; println(x+&quot; &quot;+y)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">case class Dollar(value:Double,unit:String)</span><br><span class="line">case class Currency(value:Double,unit:String)</span><br></pre></td></tr></table></figure><p>样例类提供了copy方法，构造新的对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val dollar = Dollar(20000,&quot;$&quot;)</span><br><span class="line">val ndollar = dollar.copy()</span><br></pre></td></tr></table></figure><h3 id="7-sealed"><a href="#7-sealed" class="headerlink" title="7.sealed"></a>7.sealed</h3><p>样本类的超类被封闭（sealed），封闭类除类定义文件外不能添加子类.模式匹配完成后需要确保所有情况皆被考虑,因此Scala编译器会检测match表达式所遗漏的模式组合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sealed abstract class Expr  </span><br><span class="line">case class Number( n :Int) extends Expr </span><br><span class="line">case class Sum(e1 : Expr , e2 : Expr) extends Expr  </span><br><span class="line">case class Mul(e1 : Expr , e2 : Expr) extends Expr</span><br><span class="line"></span><br><span class="line">如何定义存在可能样本遗漏的模式匹配</span><br><span class="line">def  getType(a:Expr):String = a match&#123; </span><br><span class="line">    case Number(n) =&gt; “Number“ </span><br><span class="line">    case Sum(m,n) =&gt; “Sum“</span><br><span class="line">&#125;</span><br><span class="line">warning  :  match is not exhaustive </span><br><span class="line">可以添加注解,消除warning</span><br><span class="line">def  getType(a:Expr):String = (a: @unchecked) match &#123;...&#125;</span><br></pre></td></tr></table></figure><h3 id="8-偏函数"><a href="#8-偏函数" class="headerlink" title="8.偏函数"></a>8.偏函数</h3><p>被包在花括号内的一组case语句是一个偏函数–一个并非对所有输入值都有定义的函数。它是PartialFuncation[A,B]类的一个实例。(A是参数类型，B是返回类型).Scala中的PartialFunction是一个Trait，其的类型为PartialFunction[A,B]，其中接收一个类型为A的参数，返回一个类型为B的结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">val pf :PartialFunction[Int,String] =&#123;</span><br><span class="line">      case 1 =&gt; &quot;a&quot;</span><br><span class="line">      case 2 =&gt; &quot;b&quot;</span><br><span class="line">      case 3 =&gt; &quot;c&quot;</span><br><span class="line">      case 4 =&gt; &quot;d&quot;</span><br><span class="line">      case _ =&gt; &quot;other&quot;</span><br><span class="line">&#125;</span><br><span class="line">println(pf(1))</span><br></pre></td></tr></table></figure><p>偏函数中常用的方法</p><ul><li><p>isDefinedAt:这个函数的作用是判断传入来的参数是否在这个偏函数所处理的范围内。刚才定义的pf来尝试使用isDefinedAt()，只要是Int类型都是正确的，因为有case _=&gt; “Other”这一句。如果换成其他类型就会报错。</p></li><li><p>orElse : 将多个偏函数组合起来使用，效果类似case语句。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> val onePF:PartialFunction[Int,String] = &#123;</span><br><span class="line">case 1=&gt;&quot;One&quot;</span><br><span class="line"> &#125;</span><br><span class="line"> val twoPF:PartialFunction[Int,String] = &#123;</span><br><span class="line">case 2=&gt;&quot;Two&quot;</span><br><span class="line"> &#125;</span><br><span class="line">val threePF:PartialFunction[Int,String] = &#123;</span><br><span class="line">case 3=&gt;&quot;Two&quot;</span><br><span class="line"> &#125;</span><br><span class="line">val otherPF:PartialFunction[Int,String] = &#123;</span><br><span class="line">case _=&gt;&quot;other&quot;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>//作用与上面的偏函数作用一致<br>val newPF = onePF orElse twoPF orElse threePF orElse otherPF</p></li><li><p>andThen: 相当于方法的连续调用</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">val pf :PartialFunction[Int,String] =&#123;</span><br><span class="line"></span><br><span class="line">    case 1 =&gt; &quot;a&quot;</span><br><span class="line"></span><br><span class="line">    case 2 =&gt; &quot;b&quot;</span><br><span class="line"></span><br><span class="line">    case 3 =&gt; &quot;c&quot;</span><br><span class="line"></span><br><span class="line">    case 4 =&gt; &quot;d&quot;</span><br><span class="line"></span><br><span class="line">    case _ =&gt; &quot;other&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val pf2:PartialFunction[String,String] = &#123;</span><br><span class="line"></span><br><span class="line">    case a if(a.eq(&quot;a&quot;)) =&gt; &quot;a 1&quot;</span><br><span class="line"></span><br><span class="line">    case b if(b.eq(&quot;b&quot;)) =&gt; &quot;b 2&quot;</span><br><span class="line"></span><br><span class="line">    case c if(c.eq(&quot;c&quot;)) =&gt; &quot;c 3&quot;</span><br><span class="line"></span><br><span class="line">    case d if(d.eq(&quot;d&quot;)) =&gt; &quot;d 4&quot;</span><br><span class="line"></span><br><span class="line">    case _ =&gt; &quot;other&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val newpf = pf.andThen(pf2)</span><br><span class="line"></span><br><span class="line">println(newpf(1)) //结果为　a 1</span><br></pre></td></tr></table></figure><ul><li>applyOrElse:它接收2个参数，第一个是调用的参数，第二个是个回调函数。如果第一个调用的参数匹配，返回匹配的值，否则调用回调函数。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(pf.applyOrElse(10,&#123;a:Int =&gt; &quot;ten&quot;&#125;)) // other</span><br></pre></td></tr></table></figure><h2 id="8-函数式编程"><a href="#8-函数式编程" class="headerlink" title="8.函数式编程"></a>8.函数式编程</h2><h3 id="闭包函数"><a href="#闭包函数" class="headerlink" title="闭包函数"></a>闭包函数</h3><p>闭包函数 返回的函数体引用到外部的参数,参数与函数体形成一个闭包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def cosure(x:Int)=&#123;</span><br><span class="line">   (y:Int) =&gt; x*y</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="柯里化函数"><a href="#柯里化函数" class="headerlink" title="柯里化函数"></a>柯里化函数</h3><p>将接受多个参数的函数转化成接受一个参数的函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> def mul(a:Int,b:Int,c:Int)=a*b*c</span><br><span class="line"></span><br><span class="line"> //def mut1(a:Int)(b:Int) = a*b</span><br><span class="line"> def mul1(a:Int)=(b:Int) =&gt; a*b </span><br><span class="line"> </span><br><span class="line">//def mut2(a:Int)(b:Int)(c:Int) = a*b*c</span><br><span class="line"> def mut2(a:Int) = (b:Int) =&gt; (c:Int) =&gt; a*b*c</span><br></pre></td></tr></table></figure><h2 id="9-类型系统"><a href="#9-类型系统" class="headerlink" title="9.类型系统"></a>9.类型系统</h2><h3 id="1-泛型"><a href="#1-泛型" class="headerlink" title="1.泛型"></a>1.泛型</h3><ul><li>上界: A&lt;:T；只能传入T的子类和本身</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">object TestShangJie &#123;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val compareUtil = new CompareUtil[String]</span><br><span class="line">    println(compareUtil.greater(&quot;Hello&quot;,&quot;acv&quot;))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 只用实现了Comparable的子类才可以使用该类 Comparable为上界</span><br><span class="line">class CompareUtil[T&lt;:Comparable[T]]&#123;</span><br><span class="line"></span><br><span class="line">  def greater(a:T,b:T):T=&#123;</span><br><span class="line">    if (a.compareTo(b)&gt;0) a else b</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>下界 ：A&gt;:T；只能传入T的父类和本身</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Earth&#123;</span><br><span class="line">  def sound(): Unit =&#123;</span><br><span class="line">    println(&quot;earth sound&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Animal extends Earth&#123;</span><br><span class="line">  override def sound(): Unit = &#123;</span><br><span class="line">    println(&quot;animal sound&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Dog extends Animal&#123;</span><br><span class="line"></span><br><span class="line">  override def sound(): Unit = &#123;</span><br><span class="line">    println(&quot;dog sound&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val compareUtil = new CompareUtil[String]</span><br><span class="line">    println(compareUtil.greater(&quot;Hello&quot;,&quot;acv&quot;))</span><br><span class="line"></span><br><span class="line">    val earths = Array[Earth](new Earth,new Earth)</span><br><span class="line">    val animals = Array[Animal](new Animal,new Animal)</span><br><span class="line">    val dogs =  Array[Dog](new Dog,new Dog)</span><br><span class="line">    testlLowerBound(earths).map(_.sound())</span><br><span class="line">    testlLowerBound(animals).map(_.sound())</span><br><span class="line"> // testlLowerBound(dogs).map(_.sound()) 报错</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def testlLowerBound[T&gt;:Animal](array: Array[T]): Array[T] =&#123;</span><br><span class="line">    array</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>视图界定：A&lt;%T;支持上界和隐式转换，在利用Compareble进行比较的时候，由于Int不是Comparable[Int]的子类型，不能直接进行传参比较。而scala中会将Int隐式转化成RichInt,利用视图界定,可以有效的解决Comparable不能直接传Int的问题</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 允许传入Comparable的子类和</span><br><span class="line">class CompareUtil[T&lt;% Comparable[T]]&#123;</span><br><span class="line"></span><br><span class="line">  def greater(a:T,b:T):T=&#123;</span><br><span class="line">    if (a.compareTo(b)&gt;0) a else b</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上下文界定：T:M ;要求必须存在一个类型为M[T]的”隐式值”</li></ul><p>写法一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 隐式值</span><br><span class="line"> implicit val compare = new Ordering[Emp]&#123;</span><br><span class="line">  override def compare(x: Emp, y: Emp): Int = &#123;</span><br><span class="line">    x.age-y.age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// [T:Ordering] =》 (implicit ord:Ordering[T])</span><br><span class="line">def comparatorEmp[T:Ordering](t1:T,t2:T)(implicit ord:Ordering[T]): T =&#123;</span><br><span class="line">  if(ord.compare(t1,t2)&gt;0) t1 else t2</span><br><span class="line">&#125;</span><br><span class="line">class Emp(var age:Int)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 方法调用</span><br><span class="line">def main(args: Array[String]): Unit = &#123;</span><br><span class="line">  val emp1 = new Emp(18)</span><br><span class="line">  val emp2 = new Emp(20)</span><br><span class="line">  val res = comparatorEmp(emp1,emp2)</span><br><span class="line">  println(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写法二:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def comparatorEmp[T:Ordering](t1:T,t2:T): T =&#123;</span><br><span class="line"></span><br><span class="line">  def helper(implicit ord:Ordering[T]):T = if(ord.compare(t1,t2)&gt;0) t1 else t2</span><br><span class="line">  helper</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-形变"><a href="#2-形变" class="headerlink" title="2.形变"></a>2.形变</h3><p>在java中 泛型不存在继承关系，即不存在多态但是在scala中 允许泛型之间有联系，使用型变来描述这种联系</p><ul><li>协变：C[+T]：如果A是B的子类，那么C[A]是C[B]的子类。也就是被参数化类型的泛化方向与参数类型的方向是一致的，所以称为协变。</li><li>逆变：C[-T]：如果A是B的子类，那么C[B]是C[A]的子类。也就是被参数化类型的泛化方向与参数类型的方向是相反的，所以称为逆变。</li><li>不变：C[T]：无论A和B是什么关系，C[A]和C[B]没有从属关系</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Engineer</span><br><span class="line">class Expert extends Engineer</span><br><span class="line">class Meeting[+T]//可以传入T或T的子类</span><br><span class="line">object MeetingTest&#123;</span><br><span class="line">    def participateMeeting(meeting:Meeting[Expert])=  println(&quot;welcome&quot;)</span><br><span class="line"></span><br><span class="line">        def main(args: Array[String]): Unit = &#123;</span><br><span class="line">            val m = new Meeting[Expert]</span><br><span class="line">            val m1 = new Meeting[Engineer]</span><br><span class="line"></span><br><span class="line">            participateMeeting(m)</span><br><span class="line">            participateMeeting(m1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-类型约束"><a href="#3-类型约束" class="headerlink" title="3.类型约束"></a>3.类型约束</h2><p>类型约束： 放到隐式关键字后面</p><p>​        A =:= T A是否等于T<br>        A &lt;:&lt; T A是否为T的子类<br>        A &lt;%&lt; T A是否可以隐式转化成T<br>        注意：使用类型约束需要使用implicit关键字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一-变量&quot;&gt;&lt;a href=&quot;#一-变量&quot; class=&quot;headerlink&quot; title=&quot;一.变量&quot;&gt;&lt;/a&gt;一.变量&lt;/h2&gt;&lt;h3 id=&quot;scala的数据类型&quot;&gt;&lt;a href=&quot;#scala的数据类型&quot; class=&quot;headerlink&quot; title=&quot;scala的数据类型&quot;&gt;&lt;/a&gt;scala的数据类型&lt;/h3&gt;
    
    </summary>
    
      <category term="scala" scheme="http://www.handerh.top/categories/scala/"/>
    
    
      <category term="scala" scheme="http://www.handerh.top/tags/scala/"/>
    
  </entry>
  
  <entry>
    <title>virtualbox虚拟机ubuntu无法上网</title>
    <link href="http://www.handerh.top/2019/07/21/virtualbox%E8%99%9A%E6%8B%9F%E6%9C%BAubuntu%E6%97%A0%E6%B3%95%E4%B8%8A%E7%BD%91/"/>
    <id>http://www.handerh.top/2019/07/21/virtualbox虚拟机ubuntu无法上网/</id>
    <published>2019-07-21T03:37:06.000Z</published>
    <updated>2019-08-02T01:02:05.228Z</updated>
    
    <content type="html"><![CDATA[<p>今天想要在虚拟机上安装redis，结果尽然发现虚拟机不能上网，根据网上的一顿操作，差点把自己心态搞崩，不过，最后还是集百家智慧，重要搞定了。</p><a id="more"></a><p>打开虚拟机的时候，果断 sudo apt-get install redis-server,结果发现不能上网,</p><p>ping <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> ,发现ping不同，顿时感觉不好了，于是去度娘搜了一波，过程极度坎坷，好在最后成功解决。</p><p>解决方法,配置双网卡，一个Nat模式，用来连接外网，一个host-only模式，用来虚拟机与主机之间进行交换。</p><p>一.配置Nat模式 </p><p>全局设定－－》网络－－》添加</p><p><img src="https://handerh-1259550163.cos.ap-shanghai.myqcloud.com/java/linux/%EF%BC%91.png" alt></p><p>设置–&gt;网络－－》nat模式（网卡一）</p><p><img src="https://handerh-1259550163.cos.ap-shanghai.myqcloud.com/java/linux/2.png" alt></p><p>二.设置host-only模式（网卡二）</p><p>点击管理–&gt;主机网络管理器–&gt;</p><p><img src="https://handerh-1259550163.cos.ap-shanghai.myqcloud.com/java/linux/3.png" alt></p><p>设置–&gt;网络－－》host-only</p><p><img src="https://handerh-1259550163.cos.ap-shanghai.myqcloud.com/java/linux/4.png" alt></p><p>配置文件　 sudo vi /etc/network/interfaces</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># The loopback network interface</span><br><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"></span><br><span class="line"># The primary network interface　网卡一</span><br><span class="line">auto enp0s3</span><br><span class="line">iface enp0s3 inet dhcp</span><br><span class="line">up route add default gw 10.0.2.2 dev enp0s3 #网卡一默认走网关10.0.2.2 </span><br><span class="line"># The primary network interface2　网卡二</span><br><span class="line">auto enp0s8</span><br><span class="line">iface enp0s8 inet static</span><br><span class="line">address 192.168.56.16</span><br><span class="line">gateway 192.168.56.1</span><br><span class="line">netmask 255.255.255.0</span><br><span class="line">broadcast 192.168.56.255</span><br></pre></td></tr></table></figure><p>最后都可以ping通</p><p>ping <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></p><p><img src="https://handerh-1259550163.cos.ap-shanghai.myqcloud.com/java/linux/5.png" alt></p><p>ping主机</p><p><img src="https://handerh-1259550163.cos.ap-shanghai.myqcloud.com/java/linux/6.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天想要在虚拟机上安装redis，结果尽然发现虚拟机不能上网，根据网上的一顿操作，差点把自己心态搞崩，不过，最后还是集百家智慧，重要搞定了。&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://www.handerh.top/categories/linux/"/>
    
    
      <category term="ubuntu linux" scheme="http://www.handerh.top/tags/ubuntu-linux/"/>
    
  </entry>
  
  <entry>
    <title>hadoop</title>
    <link href="http://www.handerh.top/2019/07/13/hadoop/"/>
    <id>http://www.handerh.top/2019/07/13/hadoop/</id>
    <published>2019-07-13T07:43:02.000Z</published>
    <updated>2019-08-15T06:01:29.567Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-hadoop的优势"><a href="#1-hadoop的优势" class="headerlink" title="1.hadoop的优势"></a>1.hadoop的优势</h2><ol><li><p>高可靠：维护多个副本，数据不易丢失</p></li><li><p>高扩展：集群方便添加节点</p><a id="more"></a></li><li><p>高效：MapReduce并行处理程序</p></li><li><p>高容错：提交任务失败会再次提交</p></li></ol><h2 id="2-hadoop的组成"><a href="#2-hadoop的组成" class="headerlink" title="2.hadoop的组成"></a>2.hadoop的组成</h2><ul><li><p>MapReduce:负责计算</p><p>Map阶段并行处理输入的数据</p><p>Reduce阶段对Map结果进行汇总</p></li><li><p>Yarn:资源调度</p><p>Yarn主要由ResourceManager,NodeManager,ApplicationMaster和Container等组件构成。</p><p>ResourceManager：接受客户端的请求，监控NodeManager,整个集群的资源调度和分配</p><p>NodeManager:管理单个节点的资源，处理来自ReourceManager和ApplicationMaster的命令</p><p>ApplicationMaster：负责数据的切分，为应用程序申请并且分配资源</p><p>Container:封装资源，如cpu,内存</p></li><li><p>Hdfs:数据存储</p><p>hdfs主要由NameNode,DataNode,SecondaryNameNode组成</p><p>NameNode：负责处理客户端的请求，储存元数据</p><p>DataNode：负责在本地文件系统中存储文件数据块</p><p>SecondaryNameNode:保存NameNode元数据镜像fsimage，定时到NameNode获取edit logs,并合并到fsimage,一旦有了新的fsimage，SecondaryNameNode将其拷贝到NameNode,NameNode在下次重新启动的过程中会加载这个fsimage,减少重启时间。</p></li><li><p>Commons:辅助工具</p></li></ul><h2 id="三-Hdfs"><a href="#三-Hdfs" class="headerlink" title="三.Hdfs"></a>三.Hdfs</h2><h3 id="3-1hdfs的读写流程"><a href="#3-1hdfs的读写流程" class="headerlink" title="3.1hdfs的读写流程"></a>3.1hdfs的读写流程</h3><ul><li>HDFS写文件流程</li></ul><p>​    １．客户端向NameNode发送写数据的请求<br>    ２．NameNode响应客户端的请求<br>    ３．客户端向NameNode请求发送第一个block的数据，NameNode返回可以写数据的DataNode。<br>    ４．客户端根据就近原则，选择DataNode建立连接，第一个DataNode建立连接后，会与其它的DataNode建立连接，建立一个成功的数据传输通道<br>    ５．客户端开始向第一个DataNode上传Block，以packet为单位，第一个DataNode收到packet后，会依次传递给后面的DataNode.<br>    ６．第一个block上传完毕后，会上传第二个。按照这个步骤依次上传</p><ul><li>HDFS读文件流程</li></ul><ol><li>客户端发送读文件的请求</li><li>NameNode返回目标文件的元信息（目标文件的块，块所在的位置）</li><li>客户端向最近的DataNode发送读数据的请求</li><li>DataNode开始向客户端传输数据，客户端以Packet为单位接受</li></ol><p>NameNode工作机制：启动时加载fsimage和Editlogs到内存，当客户端请求对元数据进行增删改的时候，NameNode将操作记录到Editlogs中，然后在内存中对元数据进行增删改</p><p>Secondary NameNode：会定时的向NameNode发送CheckPoint请求，将Editlogs和fsimage拷贝到Secondary NameNode进行合并，并且将新的fsimage返回给NameNode。</p><p>DataNode工作机制：一个数据块在DataNode上以文件形式存储在磁盘上，包括两个文件，一个是数据本身，一个是元数据包括数据块的长度，块数据的校验和，以及时间戳。DataNode启动后向NameNode注册，通过后，周期性（1小时）的向NameNode上报所有的块信息。DataNode会与Name进行心跳检测，每三秒一次，心跳返回结果带有NameNode给DataNode命令，如果超过10分钟没有收到某个DataNode的心跳，则认为该节点不可用。</p><h3 id="3-2-副本节点选择"><a href="#3-2-副本节点选择" class="headerlink" title="3.2 副本节点选择"></a>3.2 副本节点选择</h3><p>  假设复制因为３<br>    第一个副本：存储在客户端所在的节点(如果客户端不在集群中，则随机选择一个节点）<br>    第二个副本：存储在与客户端相同机架的不同节点<br>    第三个副本：存储在不同的机架上</p><h3 id="3-3-数据完整性"><a href="#3-3-数据完整性" class="headerlink" title="3.3.数据完整性"></a>3.3.数据完整性</h3><p>hdfs写入数据的时候会计算校验和，读数据的时候也会计算校验和，客户端读数据的时候也会计算校验和<br>除了读写之外，datanode还跑着一个后台进程（DataBlockScanner）来定期校验存在在它上面的block，因为除了读写过程中会产生数据错误以外，硬件本身也会产生数据错误。</p><p> 如果客户端发现有block坏掉，会恢复这个块<br>        1. 客户端在跑出ChecksumException之前，会向NameNode报告错误的block以及它所在的DataNode,<br>        2. NameNode将这个block标记已损坏，NameNode就不会再指向这个block,<br>        3.namenode会把一个好的block复制到datanode<br>        4.NameNode删除坏的block</p><h2 id="四-MapReduce"><a href="#四-MapReduce" class="headerlink" title="四.MapReduce"></a>四.MapReduce</h2><h3 id="4-1-MapReduce进程"><a href="#4-1-MapReduce进程" class="headerlink" title="4.1.MapReduce进程"></a>4.1.MapReduce进程</h3><p>  一个完整的MapReduce程序在分布式运行时有三类实例进程<br>            1)MrAppMaster:负责整个程序运行过程的资源调度<br>            2)MapTask:负责Map阶段的整个数据处理流程<br>            3)ReduceTask:负责Reduce阶段的整个数据处理流程</p><h3 id="4-2-文件切片"><a href="#4-2-文件切片" class="headerlink" title="4.2.文件切片"></a>4.2.文件切片</h3><p>​            １）一个job的MapTask的个数，取决于文件切片的数量<br>            ２）一个切片需要一个MapTask<br>            ３）默认情况下，切片大小为blockSize计公式（Math.max(minSize, Math.min(maxSize, blockSize));<br>            ４）切片时不考虑整体数据，针对每一个文件进行切割</p><p>默认的TextInputFormat对于每个文件进行切片，不管文件多小。</p><p> <strong>CombineTextInputFormat</strong>：用于小文件过多的场景，它可以从逻辑上将小文件划分到一个切片中</p><p> 1).需要设置虚拟存储切片的最大值：CombineTextInputFormat.setMaxInputSplitSize(job, 4194304);// 4m</p><p>2).切片机制<br>                先按照虚拟存储进行逻辑分块，小于虚拟存储分成一块，大于虚拟存储小于虚拟存储×２的，分两块，对半分。切片的时候小于虚拟存储块的与下一块合并，大于虚拟存储的单独作为一个块</p><p>测试举例：有4个小文件大小分别为1.7M、5.1M、3.4M以及6.8M这四个小文件，则虚拟存储之后形成6个文件块，大小分别为：</p><p>1.7M，（2.55M、2.55M），3.4M以及（3.4M、3.4M）</p><p>最终会形成3个切片，大小分别为：</p><p>（1.7+2.55）M，（2.55+3.4）M，（3.4+3.4）M</p><p><strong>KeyValueTextInputFormat</strong>:也是按行读取数据，键值对&lt;Text,Text&gt;,默认按tab键分割，tab键前面的为key，后面的为value。可以通过conf.set(KeyValueLineRecordReader.KEY_VALUE_SEPARATOR,”\t”)设置</p><p><strong>NLineInputFormat</strong>:不在按block进行分片，而是按照指定的行数进行分片,NLineInputFormat.setNumLinesPerSplit(job,num);</p><h3 id="4-3-Shuffle机制"><a href="#4-3-Shuffle机制" class="headerlink" title="4.3.Shuffle机制"></a>4.3.Shuffle机制</h3><p>Shuffle实在map方法之后，reduce方法之前。如图:</p><p><img src="https://handerh-1259550163.cos.ap-shanghai.myqcloud.com/java/shuffle.png" alt></p><p>1）MapTask收集我们的map()方法输出的kv对，放到内存缓冲区中</p><p>2）从内存缓冲区不断溢出本地磁盘文件，可能会溢出多个文件</p><p>3）多个溢出文件会被合并成大的溢出文件</p><p>4）在溢出过程及合并的过程中，都要调用Partitioner进行分区和针对key进行排序</p><p>5）ReduceTask根据自己的分区号，去各个MapTask机器上取相应的结果分区数据</p><p>6）ReduceTask会取到同一个分区的来自不同MapTask的结果文件，ReduceTask会将这些文件再进行合并（归并排序）</p><p>7）合并成大文件后，Shuffle的过程也就结束了，后面进入ReduceTask的逻辑运算过程（从文件中取出一个一个的键值对Group，调用用户自定义的reduce()方法）</p><h3 id="4-4-Partition-分区"><a href="#4-4-Partition-分区" class="headerlink" title="4.4.Partition 分区"></a>4.4.Partition 分区</h3><p>将统计结果按照条件输出到不同的文件</p><p>默认分区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int getPartition(K2 key, V2 value, int numReduceTasks) &#123;</span><br><span class="line">    return (key.hashCode() &amp; Integer.MAX_VALUE) % numReduceTasks;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>自定义 Partitioner 步骤</p><ol><li>自定义类继承 Partitioner， 重写 getPartition()方法</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class ProvincePartitioner extends Partitioner&lt;Text, FlowBean&gt; &#123;</span><br><span class="line">@Override</span><br><span class="line">public int getPartition(Text key, FlowBean value, int numPartitions) &#123;</span><br><span class="line">        // 1 获取电话号码的前三位</span><br><span class="line">        String preNum = key.toString().substring(0, 3);</span><br><span class="line">        int partition = 4;</span><br><span class="line">        // 2 判断是哪个省</span><br><span class="line">        if (&quot;136&quot;.equals(preNum)) &#123;</span><br><span class="line">        partition = 0;</span><br><span class="line">        &#125;else if (&quot;137&quot;.equals(preNum)) &#123;</span><br><span class="line">        partition = 1;</span><br><span class="line">        &#125;else if (&quot;138&quot;.equals(preNum)) &#123;</span><br><span class="line">        partition = 2;</span><br><span class="line">        &#125;else if (&quot;139&quot;.equals(preNum)) &#123;</span><br><span class="line">        partition = 3;</span><br><span class="line">        &#125;</span><br><span class="line">    return partition;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>在 job 驱动中，设置自定义 partitioner：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">job.setPartitionerClass(CustomPartitioner.class);</span><br></pre></td></tr></table></figure><ol start="3"><li>自定义 partition 后，要根据自定义 partitioner 的逻辑设置相应数量的 reduce task</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">job.setNumReduceTasks(5);</span><br></pre></td></tr></table></figure><p>注意:</p><p> 如果reduceTask的个数大于分区数，则会生成几个空文件<br>                如果reduceTask的个数小于分区数并且大于一，则会抛出IOException<br>                如果reduceTask的个数等于１，生成一个文件<br>                分区号必须从０开始</p><h3 id="4-5排序"><a href="#4-5排序" class="headerlink" title="4.5排序"></a>4.5排序</h3><ul><li>部分排序</li></ul><p>MapReduce 根据输入记录的键对数据集排序。 保证输出的每个文件内部排序。</p><ul><li>全排序</li></ul><p>何用 Hadoop 产生一个全局排序的文件？最简单的方法是使用一个分区。但该方法在处理大型文件时效率极低， 因为一台机器必须处理所有输出文件，从而完全丧失了MapReduce 所提供的并行架构</p><ul><li>辅助排序( GroupingComparator 分组)：</li></ul><p>在Reduce端对键进行排序。应用于：在接受的key为bean对象时，想让一个或几个字段相同的key进入到同一个reduce方法时，可以采用分组排序。</p><h3 id="4-6-Combiner-合并"><a href="#4-6-Combiner-合并" class="headerlink" title="4.6 Combiner 合并"></a>4.6 Combiner 合并</h3><p>combiner 是 MR 程序中 Mapper 和 Reducer 之外的一种组件。combiner 组件的父类就是 Reducer。combiner 和 reducer 的区别在于运行的位置：Combiner 是在每一个 maptask 所在的节点运行;<br>Reducer 是接收全局所有 Mapper 的输出结果；Combiner 的意义就是对每一个 maptask 的输出进行局部汇总，以减小网络传输量。</p><p>combiner 能够应用的前提是不能影响最终的业务逻辑，而且， combiner 的输出 kv 应该跟 reducer 的输入 kv 类型要对应起来。</p><p>比如：文件中有两行数据　</p><p>３　５　７　</p><p>２　６　　　</p><p>要对他们求平均值，如果使用 combiner进行局部汇总，最终结果为</p><p>Combiner :(3+5+7)/2=5   ,(2+6)/2=4</p><p>reducer:(5+4)/2 </p><p>不使用combiner，结果为</p><p>(3+5+7+2+6)/5=23/5</p><p>可以看到结果不相等，所有如果要使用combiner,前提是不影响业务逻辑</p><p>自定义combiner:</p><p>（ 1）自定义一个 combiner 继承 Reducer，重写 reduce 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class WordcountCombiner extends Reducer&lt;Text, IntWritable, Text,</span><br><span class="line">IntWritable&gt;&#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected void reduce(Text key, Iterable&lt;IntWritable&gt; values,</span><br><span class="line">        Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">        // 1 汇总操作</span><br><span class="line">            int count = 0;</span><br><span class="line">            for(IntWritable v :values)&#123;</span><br><span class="line">            count = v.get();</span><br><span class="line">        &#125;</span><br><span class="line">        // 2 写出</span><br><span class="line">        context.write(key, new IntWritable(count));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（ 2）在 job 驱动类中设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">job.setCombinerClass(WordcountCombiner.class);</span><br></pre></td></tr></table></figure><h3 id="4-7-MapTask-ReduceTask工作机制"><a href="#4-7-MapTask-ReduceTask工作机制" class="headerlink" title="4.7.MapTask,ReduceTask工作机制"></a>4.7.MapTask,ReduceTask工作机制</h3><p>MapTask:</p><p> 　１.reader阶段，通过RecoderReader从InputSplit中读取key/value,<br>  　2.map阶段，将读取的key/value经过map处理形成新的key/value,<br>      3.Collector收集阶段：将形成的新的key/value输出到环形缓冲区,进行分区和排序<br>      4.溢写：当环形缓冲区的数据到达一定程度后，会将数据输出到本地磁盘，形成一个临时文件，在溢写的过程中也会进行分区和排序，当溢写的文件数量到达一定程度，会对这些文件进行合并。(sortAndSpill())<br>     5.合并：当所有数据处理完成后，MapTask会将所有生成的临时文件进行合并，合并过程中是以分区为单位进行，以确保每个分区内部有序。  this.mergeParts();</p><p>ReduceTask:</p><p>​    1.Copy阶段：ReduceTask会从不同的MapTask中拷贝对应分区的数据，放在内存中，如果数据大小超过阈值，会将数据溢写到磁盘。<br>    2.Merge：ReduceTask将拷贝来的数据进行合并排序，防止内存中的文件过多<br>    3.Sort:基于key的排序，确保将相同的key的数据聚集在一起<br>    4.分组排序：将相同的key的数输入到reduce中<br>    5.reduce：reduce函数，进行数据的处理，处理后的数据写到hdfs中（调用outputformat)</p><h3 id="4-8-join操作"><a href="#4-8-join操作" class="headerlink" title="4.8.join操作"></a>4.8.join操作</h3><ul><li>Map端的join</li></ul><p>将小表置于内存中， 对于大表的一个纪录我们在内存中查找即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public class MapJoin &#123;</span><br><span class="line">    public static class MapJoinMapper extends Mapper&lt;Object, Text, Text, Text&gt; &#123;</span><br><span class="line">        public Map&lt;String, String&gt; joinData = new HashMap();</span><br><span class="line">        //执行连接操作</span><br><span class="line">        public void map(Object key, Text value, Context context) throws IOException, InterruptedException&#123;</span><br><span class="line">            String[] values = value.toString().split(&quot;\t&quot;);</span><br><span class="line">            context.write(new Text(joinData.get(values[0])), value);</span><br><span class="line">        &#125;</span><br><span class="line">        //加载小表</span><br><span class="line">        public void setup(Context context) throws IOException, InterruptedException&#123;</span><br><span class="line">            Path[] path = DistributedCache.getLocalCacheFiles(context.getConfiguration());</span><br><span class="line">            BufferedReader reader = new BufferedReader(new FileReader(path[0].toString()));</span><br><span class="line">            String str = null;</span><br><span class="line">            while((str = reader.readLine()) != null) &#123;</span><br><span class="line">                String[] s = str.split(&quot;\t&quot;);</span><br><span class="line">                joinData.put(s[0], s[1]);</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public static class MapJoinReducer extends Reducer&lt;Text, Text, Text, Text&gt; &#123;</span><br><span class="line">        public void reduce(Text key, Iterable&lt;Text&gt; values, Context context) throws IOException, InterruptedException&#123;</span><br><span class="line">            int ci = 0;</span><br><span class="line">            double total = 0.0;</span><br><span class="line">            for(Text val : values) &#123;</span><br><span class="line">                ci ++;</span><br><span class="line">                String[] v = val.toString().split(&quot;\t&quot;);</span><br><span class="line">                total += Float.parseFloat(v[1]);</span><br><span class="line">            &#125;</span><br><span class="line">            String str = String.format(&quot;%d\t%f&quot;, ci, total);</span><br><span class="line">            context.write(key, new Text(str));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        Configuration conf = new Configuration();</span><br><span class="line">        DistributedCache.addCacheFile(new Path(args[1]).toUri(), conf);</span><br><span class="line">         </span><br><span class="line">        Job job = new Job(conf, &quot;MapJoin&quot;);</span><br><span class="line">        //设置相关类</span><br><span class="line">        job.setJarByClass(MapJoin.class);</span><br><span class="line">        job.setMapperClass(MapJoinMapper.class);</span><br><span class="line">        job.setReducerClass(MapJoinReducer.class);</span><br><span class="line"> </span><br><span class="line">        //设置map输出格式</span><br><span class="line">        job.setOutputKeyClass(Text.class);</span><br><span class="line">        job.setOutputValueClass(Text.class);</span><br><span class="line">         </span><br><span class="line">        //设置输入输出文件</span><br><span class="line">        FileInputFormat.addInputPath(job, new Path(args[0]));</span><br><span class="line">        FileOutputFormat.setOutputPath(job, new Path(args[2]));</span><br><span class="line"> </span><br><span class="line">        //等待作业执行完毕</span><br><span class="line">        System.exit(job.waitForCompletion(true)?0:1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Reduce端的join</li></ul><p>将Map端输出的key相同即可reduce端进行连接，在Shuffle需要处理的数据太多，会导致效率很低、</p><h2 id="五-Yarn"><a href="#五-Yarn" class="headerlink" title="五.Yarn"></a>五.Yarn</h2><p>Yarn主要由ResourceManager,NodeManager,ApplicationMaster和Container等组件构成。<br>ReourceManager:处理客户端请求，监控NodeManager,启动或监控ApplicationMaster,资源的调度和分配<br>NodeManager:管理单个节点的资源，处理来自ReourceManager命令,处理来自ApplicationMaster的命令<br>ApplicationMaster:负责数据的切分，为应用程序申请并且分配资源<br>Container:封装资源，如cpu,内存</p><p>yarn运行机制</p><p>　1).Client调用job.waitForCompletion方法，向整个集群提交MR作业<br>    2).Client向RM请求job<br>    3).RM返回job资源提交的路径和id<br>    4).Client提交资源(文件分片信息，配置文件信息)<br>    5).资源提交完毕后，向RM申请MRAppMaster<br>    6).RM收到请求，初始化Task,将job添加到容量调度器（任务调度器）<br>    7).空闲的NM领取到该job<br>    8).NM创建一个Container,并产生MRAppMaster,下载client提交的资源<br>    9).MRAppMaster向RM申请多个MapTask.<br>    10).RM将MapTask分配给其它NM<br>    11).MapTask开始运行，进行分区排序等操作<br>    12).MRAppMaster在所有的MapTask任务完成后，向RM申请ReduceTask<br>    13)ReduceTask获取MapTask分区的数据<br>    14)程序运行完毕，MR会自动向RM申请注销自己</p><h2 id="六-任务调度器"><a href="#六-任务调度器" class="headerlink" title="六.任务调度器"></a>六.任务调度器</h2><p>FIFO调度器:按照作业的优先级高低,再按照作业的到达时间先后选择被执行.</p><p>容量调度器(Capacity Scheduler):支持多个队列,每个队列分配一定的资源量,每个队列采用FIFO调度策略,为了防止同一个用户作业独占队列中的资源,该调度器会对同一用户提交的作业占资源量进行限定,调度时,首先按以下策略选择一个合适队列, ：计算每个队列中正在运行的任务数与其应该分得的计算资源之间的比值，选择一个该比值最小的队列.</p><p>公平调度器(Fair Scheduler):支持多个队列,每个队列分配一定的资源量,每个队列的job都会按照优先级分配一定的资源,公平调度器job的优先级是根据差额来计算的,差额是指理想状态下获得的资源与实际获得的资源的差额,差额越小,优先级越高</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-hadoop的优势&quot;&gt;&lt;a href=&quot;#1-hadoop的优势&quot; class=&quot;headerlink&quot; title=&quot;1.hadoop的优势&quot;&gt;&lt;/a&gt;1.hadoop的优势&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;高可靠：维护多个副本，数据不易丢失&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;高扩展：集群方便添加节点&lt;/p&gt;
    
    </summary>
    
      <category term="hadoop" scheme="http://www.handerh.top/categories/hadoop/"/>
    
    
      <category term="hadoop" scheme="http://www.handerh.top/tags/hadoop/"/>
    
  </entry>
  
  <entry>
    <title>交换排序</title>
    <link href="http://www.handerh.top/2019/07/10/%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F/"/>
    <id>http://www.handerh.top/2019/07/10/交换排序/</id>
    <published>2019-07-10T12:30:08.000Z</published>
    <updated>2019-07-11T13:41:29.672Z</updated>
    
    <content type="html"><![CDATA[<h3 id="交换排序的基本思想"><a href="#交换排序的基本思想" class="headerlink" title="交换排序的基本思想"></a>交换排序的基本思想</h3><p>根据序列中两个元素的比较结果来对换这两个记录在序列中的位置，也就是说，将键值较大的记录向序列的尾部移动，键值较小的记录向序列的前部移动。</p><a id="more"></a><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序:"></a>冒泡排序:</h4><p>比较两个相邻的数，如果前面的数大于后面的数，则将这两个数交换位置。第一次遍历后，最大的数会被放到数组的最后位置，即array[length - 1]。第二次遍历时跳过最后一个元素，因为该元素通过第一次遍历已经确定是最大值。持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要较。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void bubleSort(int[] arr) &#123;</span><br><span class="line">for(int i=0;i&lt;arr.length-1;i++) &#123;</span><br><span class="line">for(int j=0;j&lt;arr.length-1-i;j++) &#123;</span><br><span class="line">if(arr[j]&gt;arr[j+1]) &#123;</span><br><span class="line">int tmp = arr[j];</span><br><span class="line">arr[j] = arr[j+1];</span><br><span class="line">arr[j+1] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>基本思想：</p><ol><li>先从数列中取出一个数作为基准数</li><li>分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边</li><li>再对左右区间重复第二步，直到各区间只有一个数</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public void quickSort(int arr[],int left,int right) &#123;</span><br><span class="line">if(right&gt;left) &#123;</span><br><span class="line">int index = getIndex(arr,left,right);</span><br><span class="line">quickSort(arr,left,index-1);</span><br><span class="line">quickSort(arr,index+1,right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public int getIndex(int[] arr,int left,int right) &#123;</span><br><span class="line"></span><br><span class="line">int data = arr[left];</span><br><span class="line">while(left&lt;right) &#123;</span><br><span class="line"></span><br><span class="line">while(left&lt;right&amp;&amp;arr[left]&lt;data) &#123;</span><br><span class="line">left++;</span><br><span class="line">&#125;</span><br><span class="line">arr[right] = arr[left];</span><br><span class="line">while(left&lt;right&amp;&amp;arr[right]&gt;data) &#123;</span><br><span class="line">right--;</span><br><span class="line">&#125;</span><br><span class="line">arr[left] = arr[right];</span><br><span class="line">&#125;</span><br><span class="line">arr[left] = data;</span><br><span class="line">return left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;交换排序的基本思想&quot;&gt;&lt;a href=&quot;#交换排序的基本思想&quot; class=&quot;headerlink&quot; title=&quot;交换排序的基本思想&quot;&gt;&lt;/a&gt;交换排序的基本思想&lt;/h3&gt;&lt;p&gt;根据序列中两个元素的比较结果来对换这两个记录在序列中的位置，也就是说，将键值较大的记录向序列的尾部移动，键值较小的记录向序列的前部移动。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://www.handerh.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="http://www.handerh.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>hive</title>
    <link href="http://www.handerh.top/2019/07/10/hive/"/>
    <id>http://www.handerh.top/2019/07/10/hive/</id>
    <published>2019-07-10T08:21:25.000Z</published>
    <updated>2019-08-20T10:33:25.660Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-hive的基本概念"><a href="#1-hive的基本概念" class="headerlink" title="1.hive的基本概念"></a>1.hive的基本概念</h2><p>Hive是基于hadoop的一个数据仓库工具，可以将结构化数据文件映射成一张表，并提供类sql查询功能</p><p>本质：将sql语句转化成MapReduce程序</p><ol><li><p>hive处理的数据存储在hdfs</p></li><li><p>hive分析数据底层的实现是MapReduce</p></li><li><p>执行程序运行在yarn上</p><a id="more"></a></li></ol><h2 id="2-hive的架构"><a href="#2-hive的架构" class="headerlink" title="2.hive的架构"></a>2.hive的架构</h2><p><img src="https://handerh-1259550163.cos.ap-shanghai.myqcloud.com/java/hive/hive1.png" alt></p><p>1）用户接口： Client<br>    CLI（ hive shell）、 JDBC/ODBC(java 访问 hive)</p><p>2）元数据： Metastore<br>    元数据包括：表名、表所属的数据库（默认是 default）、表的拥有者、列/分区字段、表的类型（是否是外部表）、表的数据所在目录等；</p><p>３）驱动器： Driver<br>    （ 1）解析器（ SQL Parser）：将 SQL 字符串转换成抽象语法树 AST，这一步一般都用第三方工具库完成，比如 antlr；对 AST 进行语法分析，比如表是否存在、字段是否存<br>在、 SQL 语义是否有误。<br>    （ 2）编译器（ Physical Plan）：将 AST 编译生成逻辑执行计划</p><p>​    （ 3）优化器（ Query Optimizer）：对逻辑执行计划进行优化。</p><p>​    （ 4）执行器（ Execution）：把逻辑执行计划转换成可以运行的物理计划。对于 Hive 来说，就是 MR/Spark。</p><h2 id="3-hive安装"><a href="#3-hive安装" class="headerlink" title="3.hive安装"></a>3.hive安装</h2><h3 id="1-derby形式"><a href="#1-derby形式" class="headerlink" title="1.derby形式"></a>1.derby形式</h3><p>首先将压缩包解压，并且配置环境变量。</p><p>建立一个文件加夹用来存储元数据，然后初始化元数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir /home/master/derby_data</span><br><span class="line">cd /home/master/derby_data</span><br><span class="line">//执行初始化操作</span><br><span class="line">schematool -dbType derby -initSchema</span><br></pre></td></tr></table></figure><h3 id="2-mysql形式"><a href="#2-mysql形式" class="headerlink" title="2.mysql形式"></a>2.mysql形式</h3><ol><li>首先将压缩包解压，并且配置环境变量。</li></ol><p>进入到conf/下，修改配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">vi hive-site.xml</span><br><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">        &lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt;</span><br><span class="line">        &lt;!--指定mysql--&gt;</span><br><span class="line">        &lt;value&gt;jdbc:mysql://192.168.43.22:3306/hive?createDatabaseIfNotExist=true&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">        &lt;name&gt;javax.jdo.option.ConnectionDriverName&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">        &lt;name&gt;javax.jdo.option.ConnectionUserName&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;hive&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">        &lt;name&gt;javax.jdo.option.ConnectionPassword&lt;/name&gt; &lt;value&gt;hive&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;hive.metastore.warehouse.dir&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;/user/hive/warehouse&lt;/value&gt;</span><br><span class="line">    &lt;description&gt;location of default database for the warehouse&lt;/description&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>将mysql驱动包复制到hive/lib下</li><li>在mysql中创建用户hive,密码为hive(与配置文件一致)，授予该用户权限，并且打开mysql的远程访问权限</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create user &apos;hive&apos;@&apos;192.168.43.22&apos; identified by &apos;hive&apos;;</span><br><span class="line">grant all privileges on hive.* to &apos;hive&apos;@&apos;%&apos; identified by &apos;hive&apos;;</span><br><span class="line"></span><br><span class="line">将/etc/mysql/my.conf 下面一句注释</span><br><span class="line"># bindaddress localhost</span><br></pre></td></tr></table></figure><ol start="4"><li>执行初始化命令</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schematool -dbType mysql -initSchema</span><br></pre></td></tr></table></figure><p>　4.检查mysql中是否存在hive元数据</p><h2 id="４-hive的数据类型"><a href="#４-hive的数据类型" class="headerlink" title="４.hive的数据类型"></a>４.hive的数据类型</h2><p>基本数据类型：</p><p><img src="https://handerh-1259550163.cos.ap-shanghai.myqcloud.com/java/hive/hive2.png" alt></p><p>集合数据类型：</p><p>Array(集合)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">create table tab_array (a array&lt;int&gt;,b array&lt;string&gt;)</span><br><span class="line">row format delimited</span><br><span class="line">fields terminated by &apos;\t&apos;</span><br><span class="line">collection items terminated by &apos;,&apos;;</span><br><span class="line">vi data_array</span><br><span class="line"># tab_array的内容</span><br><span class="line">1,2,3jack,Tom,lucy</span><br><span class="line">//将数据加载到tab_array中</span><br><span class="line">load data local inpath &apos;/home/master/data_array&apos; into table tab_array;</span><br><span class="line">//查询</span><br><span class="line">select a[2],b[1] from tab_array;</span><br></pre></td></tr></table></figure><p>Map(键值对):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">create table tab_map (name string,info map&lt;string,string&gt;)</span><br><span class="line">row format delimited</span><br><span class="line">fields terminated by &apos;\t&apos;</span><br><span class="line">collection items terminated by &apos;,&apos;</span><br><span class="line">map keys terminated by &apos;:&apos;;</span><br><span class="line"></span><br><span class="line">vi data_map</span><br><span class="line">zhangsan    name:zhangsan,age:18,gender:male</span><br><span class="line">load data local inpath &apos;/home/hdfs/data_map&apos; into table tab_map;</span><br><span class="line">select  info[&apos;name&apos;] from tab_map;</span><br></pre></td></tr></table></figure><p>struct(类似java的对象)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">create table tab_struct(name string,info struct&lt;age:int,tel:string,salary:double&gt;)</span><br><span class="line">row format delimited</span><br><span class="line">fields terminated by &apos;\t&apos;</span><br><span class="line">collection items terminated by &apos;,&apos;;</span><br><span class="line"></span><br><span class="line">vi data_struct</span><br><span class="line">zhangsan18,189,22.3</span><br><span class="line">load data local inpath &apos;/home/hdfs/data_struct&apos; into table tab_struct;</span><br><span class="line">select info.age,info.tel from tab_struct;</span><br></pre></td></tr></table></figure><p>综合案例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">create table test(</span><br><span class="line">name string,</span><br><span class="line">friends array&lt;string&gt;,</span><br><span class="line">children map&lt;string, int&gt;,</span><br><span class="line">address struct&lt;street:string, city:string&gt;</span><br><span class="line">)</span><br><span class="line">row format delimited fields terminated by &apos;,&apos;  --指定列分隔符为逗号</span><br><span class="line">collection items terminated by &apos;_&apos;--指定集合之间的分隔符为 _</span><br><span class="line">map keys terminated by &apos;:&apos;--指定map中key与value的分割符</span><br><span class="line"># 将下面的数据导入到表中</span><br><span class="line">jack,friend1_friend2,son1:18_son2:20,nanc_qingshanhu</span><br><span class="line">lucy,friend3_friend4,son1:18_son2:20,kunsan_bacheng</span><br></pre></td></tr></table></figure><h2 id="5-DDL数据库定义语言"><a href="#5-DDL数据库定义语言" class="headerlink" title="5.DDL数据库定义语言"></a>5.DDL数据库定义语言</h2><h4 id="数据库的操作"><a href="#数据库的操作" class="headerlink" title="数据库的操作"></a>数据库的操作</h4><p><strong>创建数据库</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create database hsj_test;</span><br><span class="line">create database if not exists hsj_test;</span><br><span class="line"># 创建数据库并指定在HDFS上的位置</span><br><span class="line">create database hsj_test3 location &apos;/hsj_test3&apos;</span><br></pre></td></tr></table></figure><p><strong>修改数据库</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alter database hsj_test3 set dbproperties(&apos;createtime&apos;=&apos;20190710&apos;);</span><br><span class="line">#　查看修改</span><br><span class="line">desc database extended hsj_test3;</span><br></pre></td></tr></table></figure><p><strong>查询数据库</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show databases;</span><br><span class="line">show databases like &apos;hsj_*&apos;;</span><br></pre></td></tr></table></figure><p><strong>显示数据库信息</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">desc database hsj_test3;</span><br><span class="line"># 显示详细信息</span><br><span class="line">desc database extended hsj_test3</span><br></pre></td></tr></table></figure><p><strong>删除数据库：</strong></p><p>数据库为空的时候才能删除否则报错,Database hsj_test3 is not empty. One or more tables exist</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop database hsj_test3; 数据库为空的时候才能删除</span><br></pre></td></tr></table></figure><h3 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h3><h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><ul><li>内部表:将数据存储在hive.metastore.warehouse.dir(例如， /user/hive/warehouse)的子目录下，删除表时，会将hdfs上的数据一同删除</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">create table inner_table(id int,name string)</span><br><span class="line">row format delimited fields terminated by &apos;,&apos; </span><br><span class="line">stored as textfile;　　　　　</span><br><span class="line">location &apos;/hdfspath&apos; 指定加载数据的路径</span><br><span class="line">＃字段说明</span><br><span class="line">row format delimited fields terminated by &apos;,&apos; // 指定列之间以,分割</span><br><span class="line">stored as textfile;　指定文件存储形式</span><br><span class="line">常用文件类型:</span><br><span class="line">SEQUENCEFILE（二进制序列文件）</span><br><span class="line">TEXTFILE（文本）</span><br><span class="line">RCFILE（列式存储格式文件）</span><br></pre></td></tr></table></figure><ul><li>外部表:删除表并不会删除hdfs上的数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create external table if not exist ext_table(id int,name string)</span><br><span class="line">row format delimited fields terminated by &apos;,&apos;;</span><br></pre></td></tr></table></figure><ul><li>分区表:根据业务编码、日期、其他类型等维度创建分区表，在一个表对应的目录下，一个分区对应一个目录.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 创建一个以月份为分区的表</span><br><span class="line">create table partition_table(id int,name string)</span><br><span class="line">partitioned by (month string)</span><br><span class="line">row format delimited fields terminated by &apos;,&apos;;</span><br><span class="line"></span><br><span class="line">load data local inpath &apos;/home/hdfs/order_data&apos; into table partition_table</span><br><span class="line">partition(month=&apos;8&apos;);</span><br><span class="line">load data local inpath &apos;/home/hdfs/order_data&apos; into table partition_table</span><br><span class="line">partition(month=&apos;７&apos;);</span><br><span class="line">去hdfs中查看，发现在该表对应的目录下，每个月份对应了一个目录</span><br></pre></td></tr></table></figure><p>分区表的查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">＃　单分区查询</span><br><span class="line">select * from t_order where month=&apos;7&apos;;</span><br><span class="line">＃　多分区联合查询</span><br><span class="line">select * from t_order where month=&apos;7&apos;</span><br><span class="line">union </span><br><span class="line">select * from t_order where month=&apos;8&apos;;</span><br></pre></td></tr></table></figure><p>增加分区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table t_order add partition(month=&apos;10&apos;);</span><br><span class="line">alter table t_order add partition(month=&apos;12&apos;) partition(month=&apos;11&apos;);</span><br></pre></td></tr></table></figure><p>删除分区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table t_order drop partition(month=&apos;10&apos;);</span><br><span class="line">alter table t_order drop partition(month=&apos;11&apos;),partition(month=&apos;12&apos;);</span><br></pre></td></tr></table></figure><p>查看分区表有多少分区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show partitions t_order;</span><br></pre></td></tr></table></figure><p>查看分区表结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">desc formatted t_order;</span><br></pre></td></tr></table></figure><p>创建二级分区表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table t_order_2(id int,name string,cost double)</span><br><span class="line">partitioned by(month string,day string)</span><br><span class="line">row format delimited fields terminated by &apos;,&apos;;</span><br><span class="line"></span><br><span class="line">load data local inpath &apos;/home/master/phone_data&apos; into table t_order_2 partition(month=&apos;1&apos;,day=&apos;20&apos;);</span><br><span class="line">load data local inpath &apos;/home/master/phone_data&apos; into table t_order_2 partition(month=&apos;2&apos;,day=&apos;20&apos;);</span><br><span class="line">load data local inpath &apos;/home/master/phone_data&apos; into table t_order_2 partition(month=&apos;1&apos;,day=&apos;15&apos;);</span><br></pre></td></tr></table></figure><p>将数据直接上传到分区目录上，让分区表和数据产生关联的两种方式</p><p>方式一：先上传后修复</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">上传数据</span><br><span class="line">hdfs dfs -mkdir -p /user/hive/warehouse/hsj_hve.db/t_order_2/month=1/day=2</span><br><span class="line">hdfs dfs -put phone_data /user/hive/warehouse/hsj_hve.db/t_order_2/month=1/day=2/</span><br><span class="line"></span><br><span class="line">select * from t_order_2 where month=&apos;1&apos; and day=&apos;2&apos;; 发现查询不到</span><br><span class="line">修复数据再查询</span><br><span class="line"> msck repair table t_order_2;</span><br></pre></td></tr></table></figure><p>方式二:上传数据后添加分区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -mkdir -p /user/hive/warehouse/hsj_hve.db/t_order_2/month=2/day=2</span><br><span class="line">hdfs dfs -put phone_data /user/hive/warehouse/hsj_hve.db/t_order_2/month=2/day=2/</span><br><span class="line">alter table add partition(month=&apos;2&apos;,day=&apos;2&apos;);</span><br></pre></td></tr></table></figure><ul><li>桶表：将大表进行哈希散列抽样存储，方便做数据和代码验证。在表对应的目录下，将源文件拆分成N个小文件。桶表中的数据，只能从其他表中用子查询进行插入</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">create table t_phone_bucket(id int,name string ,price string)</span><br><span class="line">clustered by(id) into 3 buckets</span><br><span class="line">row format delimited </span><br><span class="line">fields terminated by &apos;,&apos;;</span><br><span class="line"></span><br><span class="line">set hive.enforce.bucketing=true;</span><br><span class="line"></span><br><span class="line">insert into table t_phone_bucket select * from t_phone;</span><br><span class="line"># 桶抽样查询</span><br><span class="line">select * from t_phone_bucket tablesample(bucket 3 out of 3 on id);</span><br><span class="line"></span><br><span class="line">语法： TABLESAMPLE(BUCKET x OUT OF y)</span><br></pre></td></tr></table></figure><p>数据库抽样查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from stu tablesample(0.1 percent) ;S</span><br></pre></td></tr></table></figure><h4 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h4><p>重命名表:语法　ALTER TABLE table_name RENAME TO new_table_name</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table student rename to stu;</span><br></pre></td></tr></table></figure><p>修改列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 增加列</span><br><span class="line">alter table stu add columns(age int);</span><br><span class="line"># 替换列　膝盖表中所有字段　注意类型要匹配</span><br><span class="line">alter table stu replace columns(name string,gender string,age int);</span><br><span class="line"># 修改列</span><br><span class="line">alter table stu change column age age string</span><br></pre></td></tr></table></figure><p>##　六.DML数据操作</p><p>数据加载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load data [local] inpath &apos;/opt/module/datas/student.txt&apos; [overwrite] into table student[partition (partcol1=val1,…)];</span><br></pre></td></tr></table></figure><p>数据插入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">插入选择的数据</span><br><span class="line">insert overwrite table t_phone select * from t_phone_back;</span><br><span class="line">基本插入数据</span><br><span class="line">insert into table  p_order partition(month=&apos;10&apos;) values(1,&apos;wangwu&apos;,900.1);</span><br><span class="line">基本模式插入数据</span><br><span class="line">insert overwrite table p_order partition(month=&apos;11&apos;)</span><br><span class="line">select id, name from p_order where month=&apos;7&apos;;</span><br></pre></td></tr></table></figure><p>查询语句中创建并加载数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table if not exists stu as select id ,name from student;</span><br></pre></td></tr></table></figure><p>将数据导出到本地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insert overwrite local directory &apos;/home/master/hive_export&apos;</span><br><span class="line">row format delimited fields terminated by &apos;\t&apos;</span><br><span class="line">select * from t_order;</span><br></pre></td></tr></table></figure><p>将数据导出到hdfs</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insert overwrite  directory &apos;/home/master/hive_export&apos;</span><br><span class="line">row format delimited fields terminated by &apos;\t&apos;</span><br><span class="line">select * from t_order;</span><br></pre></td></tr></table></figure><h2 id="七查询"><a href="#七查询" class="headerlink" title="七查询"></a>七查询</h2><h4 id="group-by语句：GROUP-BY-语句通常会和聚合函数一起使用，按照一个或者多个列队结果进行分组，"><a href="#group-by语句：GROUP-BY-语句通常会和聚合函数一起使用，按照一个或者多个列队结果进行分组，" class="headerlink" title="group by语句：GROUP BY 语句通常会和聚合函数一起使用，按照一个或者多个列队结果进行分组，"></a>group by语句：GROUP BY 语句通常会和聚合函数一起使用，按照一个或者多个列队结果进行分组，</h4><p>然后对每个组执行聚合操作</p><p>计算 emp 表每个部门的平均工资</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select t.deptno, avg(t.sal) avg_sal from emp t group by t.deptno;</span><br></pre></td></tr></table></figure><p>计算 emp 每个部门中每个岗位的最高薪水</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select t.deptno, t.job, max(t.sal) max_sal from emp t group by t.deptno,</span><br><span class="line">t.job;</span><br></pre></td></tr></table></figure><h4 id="having"><a href="#having" class="headerlink" title="having:"></a>having:</h4><p>（ 1） where 针对表中的列发挥作用，查询数据； having 针对查询结果中的列发挥作用，<br>筛选数据。<br>（ 2） where 后面不能写聚合函数，而 having 后面可以使用聚合函数。<br>（ 3） having 只用于 group by 分组统计语句</p><p>求每个部门的平均薪水大于 2000 的部门</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> select deptno, avg(sal) avg_sal from emp group by deptno having avg_sal &gt;</span><br><span class="line">2000</span><br></pre></td></tr></table></figure><h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><h5 id="等值连接"><a href="#等值连接" class="headerlink" title="等值连接"></a>等值连接</h5><p>根据员工表和部门表中的部门编号相等，查询员工编号、 员工名称和部门编号；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select e.empno, e.ename, d.deptno, d.dname from emp e join dept d on</span><br><span class="line">e.deptno = d.deptno;</span><br></pre></td></tr></table></figure><h5 id="内连接"><a href="#内连接" class="headerlink" title="内连接:"></a>内连接:</h5><p>只有进行连接的两个表中都存在与连接条件相匹配的数据才会被保留下来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select e.empno, e.ename, d.deptno from emp e join dept d on e.deptno =</span><br><span class="line">d.deptno;</span><br></pre></td></tr></table></figure><h5 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接:"></a>左外连接:</h5><p>JOIN 操作符左边表中符合 WHERE 子句的所有记录将会被返回</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> select e.empno, e.ename, d.deptno from emp e left join dept d on e.deptno =</span><br><span class="line">d.deptno;</span><br></pre></td></tr></table></figure><h5 id="右外连接"><a href="#右外连接" class="headerlink" title="右外连接"></a>右外连接</h5><p>JOIN 操作符右边表中符合 WHERE 子句的所有记录将会被返回</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select e.empno, e.ename, d.deptno from emp e right join dept d on e.deptno =</span><br><span class="line">d.deptno;</span><br></pre></td></tr></table></figure><h5 id="满外连接"><a href="#满外连接" class="headerlink" title="满外连接"></a>满外连接</h5><p>将会返回所有表中符合 WHERE 语句条件的所有记录。如果任一表的指定字段没有符合条件的值的话，那么就使用 NULL 值替代</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select e.empno, e.ename, d.deptno from emp e full join dept d on e.deptno =</span><br><span class="line">d.deptno;</span><br></pre></td></tr></table></figure><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><h5 id="全局排序-order-by"><a href="#全局排序-order-by" class="headerlink" title="全局排序 order by"></a>全局排序 order by</h5><p>ASC ：升序（默认)     DESC:降序</p><p>查询员工信息按工资升序排列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from emp order by sal;</span><br></pre></td></tr></table></figure><p> 多个列排序</p><p>按照部门和工资升序排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select ename, deptno, sal from emp order by deptno, sal ;</span><br></pre></td></tr></table></figure><h5 id="内排序-sort-by"><a href="#内排序-sort-by" class="headerlink" title="内排序 sort by"></a>内排序 sort by</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">设置 reduce 个数</span><br><span class="line">set mapreduce.job.reduces=3;</span><br><span class="line">根据部门编号降序查看员工信息</span><br><span class="line">select * from emp sort by empno desc;</span><br><span class="line">将查询结果导入到文件中（按照部门编号降序排序</span><br><span class="line">insert overwrite local directory &apos;/opt/module/datas/sortby-result&apos; select *</span><br><span class="line">from emp sort by deptno desc;</span><br></pre></td></tr></table></figure><h5 id="分区排序-Distribute-By"><a href="#分区排序-Distribute-By" class="headerlink" title="分区排序 Distribute By"></a>分区排序 Distribute By</h5><p>类似 MR 中 partition，进行分区，结合 sort by 使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set mapreduce.job.reduces=3;</span><br><span class="line">insert overwrite local directory &apos;/opt/module/datas/distribute-result&apos; select *</span><br><span class="line">from emp distribute by deptno sort by empno desc;</span><br></pre></td></tr></table></figure><p> Cluster By:当 distribute by 和 sorts by 字段相同时，可以使用 cluster by 方式。</p><p>cluster by 除了具有 distribute by 的功能外还兼具 sort by 的功能。但是排序只能是倒序排序， 不能指定排序规则为 ASC 或者 DESC。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">以下两种写法等价</span><br><span class="line">select * emp cluster by deptno;</span><br><span class="line">select * from emp distribute by deptno sort by deptno;</span><br></pre></td></tr></table></figure><h5 id="行转列"><a href="#行转列" class="headerlink" title="行转列"></a>行转列</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">＃　数据</span><br><span class="line">大海射手座A</span><br><span class="line">宋宋白羊座B</span><br><span class="line">猪八戒白羊座A</span><br><span class="line">凤姐射手座A</span><br><span class="line">孙悟空白羊座A</span><br><span class="line"># 表</span><br><span class="line">create table persion_info(name string,constellation string,blood_type string)</span><br><span class="line">row format delimited fields terminated by &apos;\t&apos;;</span><br><span class="line"># 转成格式</span><br><span class="line">射手座,A大海|凤姐</span><br><span class="line">白羊座,A猪八戒|孙悟空</span><br><span class="line">白羊座,B宋宋</span><br><span class="line"></span><br><span class="line">语句</span><br><span class="line">select t.base,concat_ws(&apos;|&apos;,collect_set(t.name)) </span><br><span class="line">from </span><br><span class="line">(</span><br><span class="line">select concat(constellation,&apos;,&apos;,blood_type) base,name from persion_info</span><br><span class="line">)t</span><br><span class="line"> group by t.base;</span><br></pre></td></tr></table></figure><p>函数说明：</p><p>concat : 连接函数，用于将多个列或者字符串连接起来　concat(col1,col2,)</p><p>concat_ws:一种特殊的concat,有多个参数，第一个参数指定为连接符concat(splitor,col1,col2)，只能用来连接字符串类型或者字符串数组的列</p><p>collect_set:只接受基本类型数据，主要是将某字段的值去重汇总，产生array类型字段</p><h5 id="列转行"><a href="#列转行" class="headerlink" title="列转行"></a>列转行</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 数据</span><br><span class="line">《疑犯追踪》悬疑,动作,科幻,剧情</span><br><span class="line">《 Lie to me》悬疑,警匪,动作,心理,剧情</span><br><span class="line">《战狼 2》战争,动作,灾难</span><br><span class="line">#　表</span><br><span class="line">create table movie_info(</span><br><span class="line">movie string,</span><br><span class="line">    category array&lt;string&gt;</span><br><span class="line">    ) row format delimited fields terminated by &quot;\t&quot;</span><br><span class="line">    collection items terminated by &quot;,&quot;;</span><br><span class="line">转换格式：</span><br><span class="line">《疑犯追踪》悬疑</span><br><span class="line">《疑犯追踪》动作</span><br><span class="line">《疑犯追踪》科幻</span><br><span class="line">《疑犯追踪》剧情</span><br><span class="line">《 Lie to me》悬疑</span><br><span class="line">《 Lie to me》警匪</span><br><span class="line">《 Lie to me》动作</span><br><span class="line">《 Lie to me》心理</span><br><span class="line">《 Lie to me》剧情</span><br><span class="line">《战狼 2》战争</span><br><span class="line">《战狼 2》动作</span><br><span class="line">《战狼 2》灾难</span><br><span class="line">＃　查询语句</span><br><span class="line">select movie ,category_name from </span><br><span class="line">movie_info lateral view explode(category) table_tmp as category_name;</span><br></pre></td></tr></table></figure><p>函数说明：</p><p>LATERAL VIEW:</p><p>用法:LATERAL VIEW udtf(expression) tableAlias AS columnAlias<br>解释:用于和 split, explode 等 UDTF 一起使用，它能够将一列数据拆成多行数据，在此<br>基础上可以对拆分后的数据进行聚合。</p><h2 id="八-窗口函数"><a href="#八-窗口函数" class="headerlink" title="八.窗口函数"></a>八.窗口函数</h2><p>OVER():指定分析函数工作的数据窗口大小，这个数据窗口大小可能会随着行的变化而变化<br>CURRENT ROW:当前行<br>n PRECEDING :往前 n 行数据<br>n FOLLOWING :往后 n 行数据<br>UNBOUNDED:起点， UNBOUNDED PRECEDING 表示从前面的起点， UNBOUNDED<br>FOLLOWING 表示到后面的终点</p><p>LAG(col,n):往前第 n 行数据<br>LEAD(col,n):往后第 n 行数据<br>NTILE(n):把有序分区中的行分发到指定数据的组中，各个组有编号，编号从 1 开始，对于<br>每一行， NTILE 返回此行所属的组的编号。 注意： n 必须为 int 类型。</p><p>数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">jack,2017-01-01,10</span><br><span class="line">tony,2017-01-02,15</span><br><span class="line">jack,2017-02-03,23</span><br><span class="line">tony,2017-01-04,29</span><br><span class="line">jack,2017-01-05,46</span><br><span class="line">jack,2017-04-06,42</span><br><span class="line">tony,2017-01-07,50</span><br><span class="line">jack,2017-01-08,55</span><br><span class="line">mart,2017-04-08,62</span><br><span class="line">mart,2017-04-09,68</span><br><span class="line">neil,2017-05-10,12</span><br><span class="line">mart,2017-04-11,75</span><br><span class="line">neil,2017-06-12,80</span><br><span class="line">mart,2017-04-13,94</span><br><span class="line"># 表</span><br><span class="line"> create table business(</span><br><span class="line">    name string,</span><br><span class="line">    orderdate string,</span><br><span class="line">    cost int)</span><br><span class="line">    row format delimited fields terminated by &apos;,&apos;;</span><br></pre></td></tr></table></figure><p>1.查询在 2017 年 4 月份购买过的顾客及总人数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name,count(*) over() from business where substring(orderdate,0,7)=&apos;2017-04&apos; group by name;</span><br></pre></td></tr></table></figure><p>2.查询顾客的购买明细及月购买总额</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select *,sum(cost) over(distribute by month(orderdate);</span><br></pre></td></tr></table></figure><p>3.查询顾客的购买明细,将 cost 按照日期进行累加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select *,sum(cost) over(partition by name order by orderdate) from business;</span><br><span class="line"></span><br><span class="line"># 分区限定了窗口的界限　排序限定了窗口的大小</span><br></pre></td></tr></table></figure><p>4.查看顾客上次的购买时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * ,lag(orderdate,1) over(distribute by name order by orderdate) from business;</span><br></pre></td></tr></table></figure><p>5.查询前 20%时间的订单信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from</span><br><span class="line">(select name,orderdate,cost,ntile(5) over(order by orderdate) id from business)t</span><br><span class="line">where t.id = 1;</span><br></pre></td></tr></table></figure><h6 id="Rank函数"><a href="#Rank函数" class="headerlink" title="Rank函数"></a>Rank函数</h6><p>需要配合窗口函数over()使用</p><p>Rank() :　排序，如果有相同会重复，总数不会减少</p><p>​        假设　小明考试考了100,小刚考试考了100,小红考试考了99,那小明小刚并列第一（重复），小红第三（总数不会减少）</p><p>dense_Rank():排序，如果有相同会重复，总数会减少.</p><p>​        还是上面那个例子，明小刚并列第一（重复），小红第二（总数会减少）</p><p>row_number():按顺序排序</p><h2 id="九-函数"><a href="#九-函数" class="headerlink" title="九.函数"></a>九.函数</h2><p>系统内置函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">查看系统内置函数</span><br><span class="line">show functions;</span><br><span class="line">显示内置函数用法</span><br><span class="line">desc function upper;</span><br><span class="line">详细显示内置函数用法</span><br><span class="line">desc function extended upped</span><br></pre></td></tr></table></figure><p>自定义函数</p><p>UDF（user-defined function）：一进一出</p><p>UDAF（ User-Defined Aggregation Function):聚集函数　多进一出</p><p>UDTF（ User-Defined Table-Generating Functions）：一进多出</p><p>实现步骤</p><ol><li>继承org.apache.hadoop.hive.ql.UDF,实现evaluate方法</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public  class MyUdf extends  UDF &#123;</span><br><span class="line"></span><br><span class="line">   public String  evaluate(String phone)&#123;</span><br><span class="line">       switch (phone.substring(0,3))&#123;</span><br><span class="line">           case &quot;187&quot;:</span><br><span class="line">               return &quot;上海&quot;;</span><br><span class="line">           case &quot;159&quot;:</span><br><span class="line">               return &quot;北京&quot;;</span><br><span class="line">           case &quot;138&quot;:</span><br><span class="line">               return &quot;南昌&quot;;</span><br><span class="line">           default:</span><br><span class="line">               return &quot;未知&quot;;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>打成jar包，上传到hive所在的机器</li><li>在hive中创建一个函数，和jar中的自定义类建立</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add jar /home/master/xxxx.jar</span><br><span class="line">create [temporary] function getArea(col) as com.hsj.udf.MyUDF</span><br></pre></td></tr></table></figure><ol start="4"><li>使用</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id,name tel,getArea(tel) from t_student;</span><br></pre></td></tr></table></figure><h2 id="十-设置本地模式"><a href="#十-设置本地模式" class="headerlink" title="十.设置本地模式"></a>十.设置本地模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set hive.exec.mode.local.auto=true; </span><br><span class="line">//设置 local mr 的最大输入数据量，当输入数据量小于这个值时采用 local mr 的方式，</span><br><span class="line">默认为 134217728，即 128M</span><br><span class="line">set hive.exec.mode.local.auto.inputbytes.max=50000000;</span><br><span class="line">//设置 local mr 的最大输入文件个数，当输入文件个数小于这个值时采用 local mr 的方式，</span><br><span class="line">默认为 4</span><br><span class="line">set hive.exec.mode.local.auto.input.files.max=10;</span><br></pre></td></tr></table></figure><h2 id="十一jdbc连接hive"><a href="#十一jdbc连接hive" class="headerlink" title="十一jdbc连接hive"></a>十一jdbc连接hive</h2><ol><li>修改配置文件 hdfs-site.xml core-site.xml</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#hdfs-site.xml </span><br><span class="line">&lt;property&gt;  </span><br><span class="line">    &lt;name&gt;dfs.webhdfs.enabled&lt;/name&gt;  </span><br><span class="line">    &lt;value&gt;true&lt;/value&gt;  </span><br><span class="line">&lt;/property&gt;</span><br><span class="line">#core-site.xml</span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;hadoop.proxyuser.master.hosts&lt;/name&gt;&lt;!--允许所有主机以master登录--&gt;</span><br><span class="line">    &lt;value&gt;*&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;hadoop.proxyuser.master.groups&lt;/name&gt;&lt;!--允许任意组master登录--&gt;</span><br><span class="line">    &lt;value&gt;*&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure><p>2.jdbc api(注意先将驱动包导入)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class HiveJdbcTest &#123;</span><br><span class="line"></span><br><span class="line">    private static String driver = &quot;org.apache.hive.jdbc.HiveDriver&quot;;</span><br><span class="line">    private static  String url = &quot;jdbc:hive2://192.168.43.58:10000/hsj_test&quot;;</span><br><span class="line">    private static String user =&quot;master&quot;;</span><br><span class="line">    private static String passwd=&quot;master&quot;;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        //注册驱动　匹配到正确的驱动</span><br><span class="line">        Class.forName(driver);</span><br><span class="line">        //获取连接</span><br><span class="line">        Connection connection = DriverManager.getConnection(url, user, passwd);</span><br><span class="line">        System.out.println(connection);</span><br><span class="line">        Statement statement =</span><br><span class="line">                connection.createStatement();</span><br><span class="line">        String sql = &quot;select * from business&quot;;</span><br><span class="line">        ResultSet resultSet =</span><br><span class="line">                statement.executeQuery(sql);</span><br><span class="line">        while (resultSet.next())&#123;</span><br><span class="line">            String per = resultSet.getString(&quot;name&quot;);</span><br><span class="line">            String info = resultSet.getString(&quot;orderdate&quot;);</span><br><span class="line">            int extrainfo = resultSet.getInt(&quot;cost&quot;);</span><br><span class="line">            System.out.println(per+info+extrainfo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十二-hive结合hbase"><a href="#十二-hive结合hbase" class="headerlink" title="十二.hive结合hbase"></a>十二.hive结合hbase</h2><ol><li>hbase 中创建表</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> create &apos;person&apos;,&#123;NAME =&gt; &apos;f1&apos;,VERSIONS =&gt; 1&#125;,&#123;NAME =&gt; &apos;f2&apos;,VERSIONS =&gt; 1&#125;,&#123;NAME =&gt; &apos;f3&apos;,VERSIONS =&gt; 1&#125;</span><br><span class="line">put &apos;person&apos;,&apos;1001&apos;,&apos;f1:name&apos;,&apos;jack&apos;</span><br><span class="line">put &apos;person&apos;,&apos;1001&apos;,&apos;f2:age&apos;,&apos;18&apos;</span><br><span class="line">put &apos;person&apos;,&apos;1002&apos;,&apos;f1:name&apos;,&apos;jack&apos;</span><br><span class="line">put &apos;person&apos;,&apos;1003&apos;,&apos;f3:position&apos;,&apos;ceo</span><br></pre></td></tr></table></figure><ol start="2"><li>打开hive</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SET hbase.zookeeper.quorum=master:2181;</span><br><span class="line">SET zookeeper.znode.parent=/hbase;</span><br><span class="line"></span><br><span class="line">CREATE EXTERNAL TABLE person (</span><br><span class="line">rowkey string,</span><br><span class="line">f1 map&lt;STRING,STRING&gt;,</span><br><span class="line">f2 map&lt;STRING,STRING&gt;,</span><br><span class="line">f3 map&lt;STRING,STRING&gt;</span><br><span class="line">) STORED BY &apos;org.apache.hadoop.hive.hbase.HBaseStorageHandler&apos;</span><br><span class="line">WITH SERDEPROPERTIES (&quot;hbase.columns.mapping&quot; = &quot;:key,f1:,f2:,f3:&quot;)</span><br><span class="line">TBLPROPERTIES (&quot;hbase.table.name&quot; = &quot;person&quot;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-hive的基本概念&quot;&gt;&lt;a href=&quot;#1-hive的基本概念&quot; class=&quot;headerlink&quot; title=&quot;1.hive的基本概念&quot;&gt;&lt;/a&gt;1.hive的基本概念&lt;/h2&gt;&lt;p&gt;Hive是基于hadoop的一个数据仓库工具，可以将结构化数据文件映射成一张表，并提供类sql查询功能&lt;/p&gt;
&lt;p&gt;本质：将sql语句转化成MapReduce程序&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;hive处理的数据存储在hdfs&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;hive分析数据底层的实现是MapReduce&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;执行程序运行在yarn上&lt;/p&gt;
    
    </summary>
    
      <category term="hive" scheme="http://www.handerh.top/categories/hive/"/>
    
    
      <category term="hive" scheme="http://www.handerh.top/tags/hive/"/>
    
  </entry>
  
  <entry>
    <title>插入排序</title>
    <link href="http://www.handerh.top/2019/07/10/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>http://www.handerh.top/2019/07/10/插入排序/</id>
    <published>2019-07-10T00:48:58.000Z</published>
    <updated>2019-07-10T12:19:44.299Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-直接插入排序"><a href="#一-直接插入排序" class="headerlink" title="一.直接插入排序"></a>一.直接插入排序</h2><p>算法思想：当插入第i个元素的时候，前面的V[0],…,V[i-1]等i-1个 元素已经有序。这时，将第i个元素与前i-1个元素V[i-1]，…，V[0]依次比较，找到插入位置即将V[i]插入，同时原来位置上的元素向后顺移。在这里，插入位置的查找是顺序查找。直接插入排序是一种稳定的排序算法。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void directInsertSort(int[] arr) &#123;</span><br><span class="line">if(arr.length == 0 || arr == null) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=1;i&lt;arr.length;i++) &#123;</span><br><span class="line">for(int j=i-1;j&gt;=0;j--) &#123;</span><br><span class="line">if(arr[j]&gt;arr[j+1]) &#123;</span><br><span class="line">int tmp = arr[j+1];</span><br><span class="line">arr[j+1] = arr[j];</span><br><span class="line">arr[j] = tmp;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二-希尔排序"><a href="#二-希尔排序" class="headerlink" title="二.希尔排序"></a>二.希尔排序</h2><p>算法思想：希尔排序也是一种插入排序，只不过希尔排序是根据步长进行比较，不是与前面一个一个元素进行比较。确定步长step，将每个步长为step的元素进行比较,使用插入排序，让该序列有序，之后步长递减，将每个步长为step的元素进行比较，使用插入排序，让该序列有序，直到步长为１．</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void shellSort(int[] arr) &#123;</span><br><span class="line">//确定每次比较的步长 </span><br><span class="line">for(int step = arr.length/2;step&gt;0;step/=2) &#123;</span><br><span class="line">//　每个步长序列进行直接插入排序</span><br><span class="line">for(int i=step;i&lt;arr.length;i++) &#123;</span><br><span class="line">for(int j=i-step;j&gt;=0;j-=step) &#123;</span><br><span class="line">if(arr[j+step]&lt;arr[j]) &#123;</span><br><span class="line">int tmp = arr[j+step];</span><br><span class="line">arr[j+step]=arr[j];</span><br><span class="line">arr[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三-折半插入"><a href="#三-折半插入" class="headerlink" title="三.折半插入"></a>三.折半插入</h2><p>算法思想：当插入第i(i&gt;=1)个元素时，前面的V[0],…,V[i-1]等i-1个 元素已经有序，跟直接插入不同的是，折半插入不会与前面的元素一个个比较，而是利用二分搜索的思想，搜索到位置，进行插入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public void binarySerachInsert(int[] arr) &#123;</span><br><span class="line">for(int i=1;i&lt;arr.length;i++) &#123;</span><br><span class="line">int right = i-1;</span><br><span class="line">int left = 0;</span><br><span class="line">int tmp = arr[i];</span><br><span class="line">// 第i个元素的值小于有序序列的最大值</span><br><span class="line">if(tmp&lt;arr[right]) &#123;</span><br><span class="line">while(left&lt;=right) &#123;</span><br><span class="line">int mid = (right+left)/2;</span><br><span class="line">if(tmp&gt;arr[mid]) &#123;</span><br><span class="line">left = mid+1;</span><br><span class="line">&#125;else if(tmp&lt;arr[mid]) &#123;</span><br><span class="line">right = mid-1;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">left = left+1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int j=i;j&gt;left;j--) &#123;</span><br><span class="line">arr[j] = arr[j-1];</span><br><span class="line">&#125;</span><br><span class="line">arr[left] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一-直接插入排序&quot;&gt;&lt;a href=&quot;#一-直接插入排序&quot; class=&quot;headerlink&quot; title=&quot;一.直接插入排序&quot;&gt;&lt;/a&gt;一.直接插入排序&lt;/h2&gt;&lt;p&gt;算法思想：当插入第i个元素的时候，前面的V[0],…,V[i-1]等i-1个 元素已经有序。这时，将第i个元素与前i-1个元素V[i-1]，…，V[0]依次比较，找到插入位置即将V[i]插入，同时原来位置上的元素向后顺移。在这里，插入位置的查找是顺序查找。直接插入排序是一种稳定的排序算法。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://www.handerh.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="http://www.handerh.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
